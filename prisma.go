// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"os"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://prisma.royalek.com/algo/prod"
var Secret = os.Getenv("PRISMA_SECRET")

func (client *Client) CompanyAccount(params CompanyAccountWhereUniqueInput) *CompanyAccountExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CompanyAccountWhereUniqueInput!", "CompanyAccount"},
		"companyAccount",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExec{ret}
}

type CompanyAccountsParams struct {
	Where   *CompanyAccountWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyAccountOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) CompanyAccounts(params *CompanyAccountsParams) *CompanyAccountExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyAccountWhereInput", "CompanyAccountOrderByInput", "CompanyAccount"},
		"companyAccounts",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExecArray{ret}
}

type CompanyAccountsConnectionParams struct {
	Where   *CompanyAccountWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyAccountOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) CompanyAccountsConnection(params *CompanyAccountsConnectionParams) *CompanyAccountConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyAccountWhereInput", "CompanyAccountOrderByInput", "CompanyAccount"},
		"companyAccountsConnection",
		[]string{"edges", "pageInfo"})

	return &CompanyAccountConnectionExec{ret}
}

func (client *Client) File(params FileWhereUniqueInput) *FileExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FileWhereUniqueInput!", "File"},
		"file",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExec{ret}
}

type FilesParams struct {
	Where   *FileWhereInput   `json:"where,omitempty"`
	OrderBy *FileOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Files(params *FilesParams) *FileExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FileWhereInput", "FileOrderByInput", "File"},
		"files",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExecArray{ret}
}

type FilesConnectionParams struct {
	Where   *FileWhereInput   `json:"where,omitempty"`
	OrderBy *FileOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) FilesConnection(params *FilesConnectionParams) *FileConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FileWhereInput", "FileOrderByInput", "File"},
		"filesConnection",
		[]string{"edges", "pageInfo"})

	return &FileConnectionExec{ret}
}

func (client *Client) Order(params OrderWhereUniqueInput) *OrderExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OrderWhereUniqueInput!", "Order"},
		"order",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExec{ret}
}

type OrdersParams struct {
	Where   *OrderWhereInput   `json:"where,omitempty"`
	OrderBy *OrderOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Orders(params *OrdersParams) *OrderExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderWhereInput", "OrderOrderByInput", "Order"},
		"orders",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExecArray{ret}
}

type OrdersConnectionParams struct {
	Where   *OrderWhereInput   `json:"where,omitempty"`
	OrderBy *OrderOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) OrdersConnection(params *OrdersConnectionParams) *OrderConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderWhereInput", "OrderOrderByInput", "Order"},
		"ordersConnection",
		[]string{"edges", "pageInfo"})

	return &OrderConnectionExec{ret}
}

func (client *Client) Transaction(params TransactionWhereUniqueInput) *TransactionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TransactionWhereUniqueInput!", "Transaction"},
		"transaction",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExec{ret}
}

type TransactionsParams struct {
	Where   *TransactionWhereInput   `json:"where,omitempty"`
	OrderBy *TransactionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) Transactions(params *TransactionsParams) *TransactionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TransactionWhereInput", "TransactionOrderByInput", "Transaction"},
		"transactions",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExecArray{ret}
}

type TransactionsConnectionParams struct {
	Where   *TransactionWhereInput   `json:"where,omitempty"`
	OrderBy *TransactionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) TransactionsConnection(params *TransactionsConnectionParams) *TransactionConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TransactionWhereInput", "TransactionOrderByInput", "Transaction"},
		"transactionsConnection",
		[]string{"edges", "pageInfo"})

	return &TransactionConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) UserProfile(params UserProfileWhereUniqueInput) *UserProfileExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserProfileWhereUniqueInput!", "UserProfile"},
		"userProfile",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

type UserProfilesParams struct {
	Where   *UserProfileWhereInput   `json:"where,omitempty"`
	OrderBy *UserProfileOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) UserProfiles(params *UserProfilesParams) *UserProfileExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserProfileWhereInput", "UserProfileOrderByInput", "UserProfile"},
		"userProfiles",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExecArray{ret}
}

type UserProfilesConnectionParams struct {
	Where   *UserProfileWhereInput   `json:"where,omitempty"`
	OrderBy *UserProfileOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) UserProfilesConnection(params *UserProfilesConnectionParams) *UserProfileConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserProfileWhereInput", "UserProfileOrderByInput", "UserProfile"},
		"userProfilesConnection",
		[]string{"edges", "pageInfo"})

	return &UserProfileConnectionExec{ret}
}

func (client *Client) UserRole(params UserRoleWhereUniqueInput) *UserRoleExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserRoleWhereUniqueInput!", "UserRole"},
		"userRole",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExec{ret}
}

type UserRolesParams struct {
	Where   *UserRoleWhereInput   `json:"where,omitempty"`
	OrderBy *UserRoleOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) UserRoles(params *UserRolesParams) *UserRoleExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserRoleWhereInput", "UserRoleOrderByInput", "UserRole"},
		"userRoles",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExecArray{ret}
}

type UserRolesConnectionParams struct {
	Where   *UserRoleWhereInput   `json:"where,omitempty"`
	OrderBy *UserRoleOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) UserRolesConnection(params *UserRolesConnectionParams) *UserRoleConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserRoleWhereInput", "UserRoleOrderByInput", "UserRole"},
		"userRolesConnection",
		[]string{"edges", "pageInfo"})

	return &UserRoleConnectionExec{ret}
}

func (client *Client) Wallet(params WalletWhereUniqueInput) *WalletExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"WalletWhereUniqueInput!", "Wallet"},
		"wallet",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

type WalletsParams struct {
	Where   *WalletWhereInput   `json:"where,omitempty"`
	OrderBy *WalletOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Wallets(params *WalletsParams) *WalletExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "Wallet"},
		"wallets",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExecArray{ret}
}

type WalletsConnectionParams struct {
	Where   *WalletWhereInput   `json:"where,omitempty"`
	OrderBy *WalletOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) WalletsConnection(params *WalletsConnectionParams) *WalletConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "Wallet"},
		"walletsConnection",
		[]string{"edges", "pageInfo"})

	return &WalletConnectionExec{ret}
}

func (client *Client) CreateCompanyAccount(params CompanyAccountCreateInput) *CompanyAccountExec {
	ret := client.Client.Create(
		params,
		[2]string{"CompanyAccountCreateInput!", "CompanyAccount"},
		"createCompanyAccount",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExec{ret}
}

type CompanyAccountUpdateParams struct {
	Data  CompanyAccountUpdateInput      `json:"data"`
	Where CompanyAccountWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCompanyAccount(params CompanyAccountUpdateParams) *CompanyAccountExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CompanyAccountUpdateInput!", "CompanyAccountWhereUniqueInput!", "CompanyAccount"},
		"updateCompanyAccount",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExec{ret}
}

type CompanyAccountUpdateManyParams struct {
	Data  CompanyAccountUpdateManyMutationInput `json:"data"`
	Where *CompanyAccountWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCompanyAccounts(params CompanyAccountUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CompanyAccountUpdateManyMutationInput!", "CompanyAccountWhereInput"},
		"updateManyCompanyAccounts")
	return &BatchPayloadExec{exec}
}

type CompanyAccountUpsertParams struct {
	Where  CompanyAccountWhereUniqueInput `json:"where"`
	Create CompanyAccountCreateInput      `json:"create"`
	Update CompanyAccountUpdateInput      `json:"update"`
}

func (client *Client) UpsertCompanyAccount(params CompanyAccountUpsertParams) *CompanyAccountExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CompanyAccountWhereUniqueInput!", "CompanyAccountCreateInput!", "CompanyAccountUpdateInput!", "CompanyAccount"},
		"upsertCompanyAccount",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExec{ret}
}

func (client *Client) DeleteCompanyAccount(params CompanyAccountWhereUniqueInput) *CompanyAccountExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CompanyAccountWhereUniqueInput!", "CompanyAccount"},
		"deleteCompanyAccount",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExec{ret}
}

func (client *Client) DeleteManyCompanyAccounts(params *CompanyAccountWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CompanyAccountWhereInput", "deleteManyCompanyAccounts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFile(params FileCreateInput) *FileExec {
	ret := client.Client.Create(
		params,
		[2]string{"FileCreateInput!", "File"},
		"createFile",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExec{ret}
}

type FileUpdateParams struct {
	Data  FileUpdateInput      `json:"data"`
	Where FileWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFile(params FileUpdateParams) *FileExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FileUpdateInput!", "FileWhereUniqueInput!", "File"},
		"updateFile",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExec{ret}
}

type FileUpdateManyParams struct {
	Data  FileUpdateManyMutationInput `json:"data"`
	Where *FileWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFiles(params FileUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FileUpdateManyMutationInput!", "FileWhereInput"},
		"updateManyFiles")
	return &BatchPayloadExec{exec}
}

type FileUpsertParams struct {
	Where  FileWhereUniqueInput `json:"where"`
	Create FileCreateInput      `json:"create"`
	Update FileUpdateInput      `json:"update"`
}

func (client *Client) UpsertFile(params FileUpsertParams) *FileExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FileWhereUniqueInput!", "FileCreateInput!", "FileUpdateInput!", "File"},
		"upsertFile",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExec{ret}
}

func (client *Client) DeleteFile(params FileWhereUniqueInput) *FileExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FileWhereUniqueInput!", "File"},
		"deleteFile",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExec{ret}
}

func (client *Client) DeleteManyFiles(params *FileWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FileWhereInput", "deleteManyFiles")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOrder(params OrderCreateInput) *OrderExec {
	ret := client.Client.Create(
		params,
		[2]string{"OrderCreateInput!", "Order"},
		"createOrder",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExec{ret}
}

type OrderUpdateParams struct {
	Data  OrderUpdateInput      `json:"data"`
	Where OrderWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOrder(params OrderUpdateParams) *OrderExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OrderUpdateInput!", "OrderWhereUniqueInput!", "Order"},
		"updateOrder",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExec{ret}
}

type OrderUpdateManyParams struct {
	Data  OrderUpdateManyMutationInput `json:"data"`
	Where *OrderWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOrders(params OrderUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OrderUpdateManyMutationInput!", "OrderWhereInput"},
		"updateManyOrders")
	return &BatchPayloadExec{exec}
}

type OrderUpsertParams struct {
	Where  OrderWhereUniqueInput `json:"where"`
	Create OrderCreateInput      `json:"create"`
	Update OrderUpdateInput      `json:"update"`
}

func (client *Client) UpsertOrder(params OrderUpsertParams) *OrderExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OrderWhereUniqueInput!", "OrderCreateInput!", "OrderUpdateInput!", "Order"},
		"upsertOrder",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExec{ret}
}

func (client *Client) DeleteOrder(params OrderWhereUniqueInput) *OrderExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OrderWhereUniqueInput!", "Order"},
		"deleteOrder",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExec{ret}
}

func (client *Client) DeleteManyOrders(params *OrderWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OrderWhereInput", "deleteManyOrders")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTransaction(params TransactionCreateInput) *TransactionExec {
	ret := client.Client.Create(
		params,
		[2]string{"TransactionCreateInput!", "Transaction"},
		"createTransaction",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExec{ret}
}

type TransactionUpdateParams struct {
	Data  TransactionUpdateInput      `json:"data"`
	Where TransactionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTransaction(params TransactionUpdateParams) *TransactionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TransactionUpdateInput!", "TransactionWhereUniqueInput!", "Transaction"},
		"updateTransaction",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExec{ret}
}

type TransactionUpdateManyParams struct {
	Data  TransactionUpdateManyMutationInput `json:"data"`
	Where *TransactionWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTransactions(params TransactionUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TransactionUpdateManyMutationInput!", "TransactionWhereInput"},
		"updateManyTransactions")
	return &BatchPayloadExec{exec}
}

type TransactionUpsertParams struct {
	Where  TransactionWhereUniqueInput `json:"where"`
	Create TransactionCreateInput      `json:"create"`
	Update TransactionUpdateInput      `json:"update"`
}

func (client *Client) UpsertTransaction(params TransactionUpsertParams) *TransactionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TransactionWhereUniqueInput!", "TransactionCreateInput!", "TransactionUpdateInput!", "Transaction"},
		"upsertTransaction",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExec{ret}
}

func (client *Client) DeleteTransaction(params TransactionWhereUniqueInput) *TransactionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TransactionWhereUniqueInput!", "Transaction"},
		"deleteTransaction",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExec{ret}
}

func (client *Client) DeleteManyTransactions(params *TransactionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TransactionWhereInput", "deleteManyTransactions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUserProfile(params UserProfileCreateInput) *UserProfileExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserProfileCreateInput!", "UserProfile"},
		"createUserProfile",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

type UserProfileUpdateParams struct {
	Data  UserProfileUpdateInput      `json:"data"`
	Where UserProfileWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUserProfile(params UserProfileUpdateParams) *UserProfileExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserProfileUpdateInput!", "UserProfileWhereUniqueInput!", "UserProfile"},
		"updateUserProfile",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

type UserProfileUpdateManyParams struct {
	Data  UserProfileUpdateManyMutationInput `json:"data"`
	Where *UserProfileWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUserProfiles(params UserProfileUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserProfileUpdateManyMutationInput!", "UserProfileWhereInput"},
		"updateManyUserProfiles")
	return &BatchPayloadExec{exec}
}

type UserProfileUpsertParams struct {
	Where  UserProfileWhereUniqueInput `json:"where"`
	Create UserProfileCreateInput      `json:"create"`
	Update UserProfileUpdateInput      `json:"update"`
}

func (client *Client) UpsertUserProfile(params UserProfileUpsertParams) *UserProfileExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserProfileWhereUniqueInput!", "UserProfileCreateInput!", "UserProfileUpdateInput!", "UserProfile"},
		"upsertUserProfile",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

func (client *Client) DeleteUserProfile(params UserProfileWhereUniqueInput) *UserProfileExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserProfileWhereUniqueInput!", "UserProfile"},
		"deleteUserProfile",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

func (client *Client) DeleteManyUserProfiles(params *UserProfileWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserProfileWhereInput", "deleteManyUserProfiles")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUserRole(params UserRoleCreateInput) *UserRoleExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserRoleCreateInput!", "UserRole"},
		"createUserRole",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExec{ret}
}

type UserRoleUpdateParams struct {
	Data  UserRoleUpdateInput      `json:"data"`
	Where UserRoleWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUserRole(params UserRoleUpdateParams) *UserRoleExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserRoleUpdateInput!", "UserRoleWhereUniqueInput!", "UserRole"},
		"updateUserRole",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExec{ret}
}

type UserRoleUpdateManyParams struct {
	Data  UserRoleUpdateManyMutationInput `json:"data"`
	Where *UserRoleWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUserRoles(params UserRoleUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserRoleUpdateManyMutationInput!", "UserRoleWhereInput"},
		"updateManyUserRoles")
	return &BatchPayloadExec{exec}
}

type UserRoleUpsertParams struct {
	Where  UserRoleWhereUniqueInput `json:"where"`
	Create UserRoleCreateInput      `json:"create"`
	Update UserRoleUpdateInput      `json:"update"`
}

func (client *Client) UpsertUserRole(params UserRoleUpsertParams) *UserRoleExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserRoleWhereUniqueInput!", "UserRoleCreateInput!", "UserRoleUpdateInput!", "UserRole"},
		"upsertUserRole",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExec{ret}
}

func (client *Client) DeleteUserRole(params UserRoleWhereUniqueInput) *UserRoleExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserRoleWhereUniqueInput!", "UserRole"},
		"deleteUserRole",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExec{ret}
}

func (client *Client) DeleteManyUserRoles(params *UserRoleWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserRoleWhereInput", "deleteManyUserRoles")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateWallet(params WalletCreateInput) *WalletExec {
	ret := client.Client.Create(
		params,
		[2]string{"WalletCreateInput!", "Wallet"},
		"createWallet",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

type WalletUpdateParams struct {
	Data  WalletUpdateInput      `json:"data"`
	Where WalletWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateWallet(params WalletUpdateParams) *WalletExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"WalletUpdateInput!", "WalletWhereUniqueInput!", "Wallet"},
		"updateWallet",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

type WalletUpdateManyParams struct {
	Data  WalletUpdateManyMutationInput `json:"data"`
	Where *WalletWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyWallets(params WalletUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"WalletUpdateManyMutationInput!", "WalletWhereInput"},
		"updateManyWallets")
	return &BatchPayloadExec{exec}
}

type WalletUpsertParams struct {
	Where  WalletWhereUniqueInput `json:"where"`
	Create WalletCreateInput      `json:"create"`
	Update WalletUpdateInput      `json:"update"`
}

func (client *Client) UpsertWallet(params WalletUpsertParams) *WalletExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"WalletWhereUniqueInput!", "WalletCreateInput!", "WalletUpdateInput!", "Wallet"},
		"upsertWallet",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

func (client *Client) DeleteWallet(params WalletWhereUniqueInput) *WalletExec {
	ret := client.Client.Delete(
		params,
		[2]string{"WalletWhereUniqueInput!", "Wallet"},
		"deleteWallet",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

func (client *Client) DeleteManyWallets(params *WalletWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "WalletWhereInput", "deleteManyWallets")
	return &BatchPayloadExec{exec}
}

type OrderStatus string

const (
	OrderStatusLong     OrderStatus = "LONG"
	OrderStatusLongTp   OrderStatus = "LONG_TP"
	OrderStatusLongSl   OrderStatus = "LONG_SL"
	OrderStatusShort    OrderStatus = "SHORT"
	OrderStatusShortTp  OrderStatus = "SHORT_TP"
	OrderStatusShortSl  OrderStatus = "SHORT_SL"
	OrderStatusLong50   OrderStatus = "LONG50"
	OrderStatusLong100  OrderStatus = "LONG100"
	OrderStatusShort50  OrderStatus = "SHORT50"
	OrderStatusShort100 OrderStatus = "SHORT100"
)

type OrderOrderByInput string

const (
	OrderOrderByInputIDAsc         OrderOrderByInput = "id_ASC"
	OrderOrderByInputIDDesc        OrderOrderByInput = "id_DESC"
	OrderOrderByInputTypeAsc       OrderOrderByInput = "type_ASC"
	OrderOrderByInputTypeDesc      OrderOrderByInput = "type_DESC"
	OrderOrderByInputPriceAsc      OrderOrderByInput = "price_ASC"
	OrderOrderByInputPriceDesc     OrderOrderByInput = "price_DESC"
	OrderOrderByInputExitPriceAsc  OrderOrderByInput = "exitPrice_ASC"
	OrderOrderByInputExitPriceDesc OrderOrderByInput = "exitPrice_DESC"
	OrderOrderByInputAmountAsc     OrderOrderByInput = "amount_ASC"
	OrderOrderByInputAmountDesc    OrderOrderByInput = "amount_DESC"
	OrderOrderByInputSymbolAsc     OrderOrderByInput = "symbol_ASC"
	OrderOrderByInputSymbolDesc    OrderOrderByInput = "symbol_DESC"
	OrderOrderByInputStatusAsc     OrderOrderByInput = "status_ASC"
	OrderOrderByInputStatusDesc    OrderOrderByInput = "status_DESC"
	OrderOrderByInputTimeframeAsc  OrderOrderByInput = "timeframe_ASC"
	OrderOrderByInputTimeframeDesc OrderOrderByInput = "timeframe_DESC"
	OrderOrderByInputMarketAsc     OrderOrderByInput = "market_ASC"
	OrderOrderByInputMarketDesc    OrderOrderByInput = "market_DESC"
	OrderOrderByInputStrategyAsc   OrderOrderByInput = "strategy_ASC"
	OrderOrderByInputStrategyDesc  OrderOrderByInput = "strategy_DESC"
	OrderOrderByInputCreatedAtAsc  OrderOrderByInput = "createdAt_ASC"
	OrderOrderByInputCreatedAtDesc OrderOrderByInput = "createdAt_DESC"
	OrderOrderByInputUpdatedAtAsc  OrderOrderByInput = "updatedAt_ASC"
	OrderOrderByInputUpdatedAtDesc OrderOrderByInput = "updatedAt_DESC"
)

type CompanyAccountOrderByInput string

const (
	CompanyAccountOrderByInputIDAsc         CompanyAccountOrderByInput = "id_ASC"
	CompanyAccountOrderByInputIDDesc        CompanyAccountOrderByInput = "id_DESC"
	CompanyAccountOrderByInputMarketAsc     CompanyAccountOrderByInput = "market_ASC"
	CompanyAccountOrderByInputMarketDesc    CompanyAccountOrderByInput = "market_DESC"
	CompanyAccountOrderByInputBalanceAsc    CompanyAccountOrderByInput = "balance_ASC"
	CompanyAccountOrderByInputBalanceDesc   CompanyAccountOrderByInput = "balance_DESC"
	CompanyAccountOrderByInputCreatedAtAsc  CompanyAccountOrderByInput = "createdAt_ASC"
	CompanyAccountOrderByInputCreatedAtDesc CompanyAccountOrderByInput = "createdAt_DESC"
	CompanyAccountOrderByInputUpdatedAtAsc  CompanyAccountOrderByInput = "updatedAt_ASC"
	CompanyAccountOrderByInputUpdatedAtDesc CompanyAccountOrderByInput = "updatedAt_DESC"
)

type FileOrderByInput string

const (
	FileOrderByInputIDAsc         FileOrderByInput = "id_ASC"
	FileOrderByInputIDDesc        FileOrderByInput = "id_DESC"
	FileOrderByInputCreatedAtAsc  FileOrderByInput = "createdAt_ASC"
	FileOrderByInputCreatedAtDesc FileOrderByInput = "createdAt_DESC"
	FileOrderByInputUpdatedAtAsc  FileOrderByInput = "updatedAt_ASC"
	FileOrderByInputUpdatedAtDesc FileOrderByInput = "updatedAt_DESC"
	FileOrderByInputFilenameAsc   FileOrderByInput = "filename_ASC"
	FileOrderByInputFilenameDesc  FileOrderByInput = "filename_DESC"
	FileOrderByInputMimetypeAsc   FileOrderByInput = "mimetype_ASC"
	FileOrderByInputMimetypeDesc  FileOrderByInput = "mimetype_DESC"
	FileOrderByInputEncodingAsc   FileOrderByInput = "encoding_ASC"
	FileOrderByInputEncodingDesc  FileOrderByInput = "encoding_DESC"
	FileOrderByInputMetaAsc       FileOrderByInput = "meta_ASC"
	FileOrderByInputMetaDesc      FileOrderByInput = "meta_DESC"
	FileOrderByInputUrlAsc        FileOrderByInput = "url_ASC"
	FileOrderByInputUrlDesc       FileOrderByInput = "url_DESC"
)

type TransactionType string

const (
	TransactionTypeDeposit    TransactionType = "DEPOSIT"
	TransactionTypeWithdrawal TransactionType = "WITHDRAWAL"
)

type DepositWithdrawalStatus string

const (
	DepositWithdrawalStatusPending  DepositWithdrawalStatus = "PENDING"
	DepositWithdrawalStatusApproved DepositWithdrawalStatus = "APPROVED"
	DepositWithdrawalStatusRejected DepositWithdrawalStatus = "REJECTED"
)

type TransactionOrderByInput string

const (
	TransactionOrderByInputIDAsc         TransactionOrderByInput = "id_ASC"
	TransactionOrderByInputIDDesc        TransactionOrderByInput = "id_DESC"
	TransactionOrderByInputCurrencyAsc   TransactionOrderByInput = "currency_ASC"
	TransactionOrderByInputCurrencyDesc  TransactionOrderByInput = "currency_DESC"
	TransactionOrderByInputAmountAsc     TransactionOrderByInput = "amount_ASC"
	TransactionOrderByInputAmountDesc    TransactionOrderByInput = "amount_DESC"
	TransactionOrderByInputTypeAsc       TransactionOrderByInput = "type_ASC"
	TransactionOrderByInputTypeDesc      TransactionOrderByInput = "type_DESC"
	TransactionOrderByInputStatusAsc     TransactionOrderByInput = "status_ASC"
	TransactionOrderByInputStatusDesc    TransactionOrderByInput = "status_DESC"
	TransactionOrderByInputCreatedAtAsc  TransactionOrderByInput = "createdAt_ASC"
	TransactionOrderByInputCreatedAtDesc TransactionOrderByInput = "createdAt_DESC"
	TransactionOrderByInputUpdatedAtAsc  TransactionOrderByInput = "updatedAt_ASC"
	TransactionOrderByInputUpdatedAtDesc TransactionOrderByInput = "updatedAt_DESC"
)

type RoleNamespace string

const (
	RoleNamespaceGlobal RoleNamespace = "GLOBAL"
	RoleNamespaceElearn RoleNamespace = "ELEARN"
	RoleNamespaceTeams  RoleNamespace = "TEAMS"
	RoleNamespaceJoin   RoleNamespace = "JOIN"
)

type UserRoleOrderByInput string

const (
	UserRoleOrderByInputIDAsc          UserRoleOrderByInput = "id_ASC"
	UserRoleOrderByInputIDDesc         UserRoleOrderByInput = "id_DESC"
	UserRoleOrderByInputNamespaceAsc   UserRoleOrderByInput = "namespace_ASC"
	UserRoleOrderByInputNamespaceDesc  UserRoleOrderByInput = "namespace_DESC"
	UserRoleOrderByInputPermissionAsc  UserRoleOrderByInput = "permission_ASC"
	UserRoleOrderByInputPermissionDesc UserRoleOrderByInput = "permission_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc             UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc            UserOrderByInput = "id_DESC"
	UserOrderByInputEmailAsc          UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc         UserOrderByInput = "email_DESC"
	UserOrderByInputPasswordAsc       UserOrderByInput = "password_ASC"
	UserOrderByInputPasswordDesc      UserOrderByInput = "password_DESC"
	UserOrderByInputEmailVerifiedAsc  UserOrderByInput = "emailVerified_ASC"
	UserOrderByInputEmailVerifiedDesc UserOrderByInput = "emailVerified_DESC"
	UserOrderByInputUsernameAsc       UserOrderByInput = "username_ASC"
	UserOrderByInputUsernameDesc      UserOrderByInput = "username_DESC"
	UserOrderByInputNricAsc           UserOrderByInput = "nric_ASC"
	UserOrderByInputNricDesc          UserOrderByInput = "nric_DESC"
	UserOrderByInputCreatedAtAsc      UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc     UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc      UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc     UserOrderByInput = "updatedAt_DESC"
)

type UserProfileOrderByInput string

const (
	UserProfileOrderByInputIDAsc            UserProfileOrderByInput = "id_ASC"
	UserProfileOrderByInputIDDesc           UserProfileOrderByInput = "id_DESC"
	UserProfileOrderByInputAddressAsc       UserProfileOrderByInput = "address_ASC"
	UserProfileOrderByInputAddressDesc      UserProfileOrderByInput = "address_DESC"
	UserProfileOrderByInputAgeAsc           UserProfileOrderByInput = "age_ASC"
	UserProfileOrderByInputAgeDesc          UserProfileOrderByInput = "age_DESC"
	UserProfileOrderByInputCitizenshipAsc   UserProfileOrderByInput = "citizenship_ASC"
	UserProfileOrderByInputCitizenshipDesc  UserProfileOrderByInput = "citizenship_DESC"
	UserProfileOrderByInputCountryAsc       UserProfileOrderByInput = "country_ASC"
	UserProfileOrderByInputCountryDesc      UserProfileOrderByInput = "country_DESC"
	UserProfileOrderByInputDateOfBirthAsc   UserProfileOrderByInput = "dateOfBirth_ASC"
	UserProfileOrderByInputDateOfBirthDesc  UserProfileOrderByInput = "dateOfBirth_DESC"
	UserProfileOrderByInputFullNameAsc      UserProfileOrderByInput = "fullName_ASC"
	UserProfileOrderByInputFullNameDesc     UserProfileOrderByInput = "fullName_DESC"
	UserProfileOrderByInputOccupationAsc    UserProfileOrderByInput = "occupation_ASC"
	UserProfileOrderByInputOccupationDesc   UserProfileOrderByInput = "occupation_DESC"
	UserProfileOrderByInputOrganisationAsc  UserProfileOrderByInput = "organisation_ASC"
	UserProfileOrderByInputOrganisationDesc UserProfileOrderByInput = "organisation_DESC"
	UserProfileOrderByInputPhoneAsc         UserProfileOrderByInput = "phone_ASC"
	UserProfileOrderByInputPhoneDesc        UserProfileOrderByInput = "phone_DESC"
)

type WalletOrderByInput string

const (
	WalletOrderByInputIDAsc         WalletOrderByInput = "id_ASC"
	WalletOrderByInputIDDesc        WalletOrderByInput = "id_DESC"
	WalletOrderByInputBalanceAsc    WalletOrderByInput = "balance_ASC"
	WalletOrderByInputBalanceDesc   WalletOrderByInput = "balance_DESC"
	WalletOrderByInputCreatedAtAsc  WalletOrderByInput = "createdAt_ASC"
	WalletOrderByInputCreatedAtDesc WalletOrderByInput = "createdAt_DESC"
	WalletOrderByInputUpdatedAtAsc  WalletOrderByInput = "updatedAt_ASC"
	WalletOrderByInputUpdatedAtDesc WalletOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type CompanyAccountWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type OrderWhereInput struct {
	ID                     *string           `json:"id,omitempty"`
	IDNot                  *string           `json:"id_not,omitempty"`
	IDIn                   []string          `json:"id_in,omitempty"`
	IDNotIn                []string          `json:"id_not_in,omitempty"`
	IDLt                   *string           `json:"id_lt,omitempty"`
	IDLte                  *string           `json:"id_lte,omitempty"`
	IDGt                   *string           `json:"id_gt,omitempty"`
	IDGte                  *string           `json:"id_gte,omitempty"`
	IDContains             *string           `json:"id_contains,omitempty"`
	IDNotContains          *string           `json:"id_not_contains,omitempty"`
	IDStartsWith           *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string           `json:"id_not_ends_with,omitempty"`
	Type                   *string           `json:"type,omitempty"`
	TypeNot                *string           `json:"type_not,omitempty"`
	TypeIn                 []string          `json:"type_in,omitempty"`
	TypeNotIn              []string          `json:"type_not_in,omitempty"`
	TypeLt                 *string           `json:"type_lt,omitempty"`
	TypeLte                *string           `json:"type_lte,omitempty"`
	TypeGt                 *string           `json:"type_gt,omitempty"`
	TypeGte                *string           `json:"type_gte,omitempty"`
	TypeContains           *string           `json:"type_contains,omitempty"`
	TypeNotContains        *string           `json:"type_not_contains,omitempty"`
	TypeStartsWith         *string           `json:"type_starts_with,omitempty"`
	TypeNotStartsWith      *string           `json:"type_not_starts_with,omitempty"`
	TypeEndsWith           *string           `json:"type_ends_with,omitempty"`
	TypeNotEndsWith        *string           `json:"type_not_ends_with,omitempty"`
	Price                  *float64          `json:"price,omitempty"`
	PriceNot               *float64          `json:"price_not,omitempty"`
	PriceIn                []float64         `json:"price_in,omitempty"`
	PriceNotIn             []float64         `json:"price_not_in,omitempty"`
	PriceLt                *float64          `json:"price_lt,omitempty"`
	PriceLte               *float64          `json:"price_lte,omitempty"`
	PriceGt                *float64          `json:"price_gt,omitempty"`
	PriceGte               *float64          `json:"price_gte,omitempty"`
	ExitPrice              *float64          `json:"exitPrice,omitempty"`
	ExitPriceNot           *float64          `json:"exitPrice_not,omitempty"`
	ExitPriceIn            []float64         `json:"exitPrice_in,omitempty"`
	ExitPriceNotIn         []float64         `json:"exitPrice_not_in,omitempty"`
	ExitPriceLt            *float64          `json:"exitPrice_lt,omitempty"`
	ExitPriceLte           *float64          `json:"exitPrice_lte,omitempty"`
	ExitPriceGt            *float64          `json:"exitPrice_gt,omitempty"`
	ExitPriceGte           *float64          `json:"exitPrice_gte,omitempty"`
	Amount                 *float64          `json:"amount,omitempty"`
	AmountNot              *float64          `json:"amount_not,omitempty"`
	AmountIn               []float64         `json:"amount_in,omitempty"`
	AmountNotIn            []float64         `json:"amount_not_in,omitempty"`
	AmountLt               *float64          `json:"amount_lt,omitempty"`
	AmountLte              *float64          `json:"amount_lte,omitempty"`
	AmountGt               *float64          `json:"amount_gt,omitempty"`
	AmountGte              *float64          `json:"amount_gte,omitempty"`
	Symbol                 *string           `json:"symbol,omitempty"`
	SymbolNot              *string           `json:"symbol_not,omitempty"`
	SymbolIn               []string          `json:"symbol_in,omitempty"`
	SymbolNotIn            []string          `json:"symbol_not_in,omitempty"`
	SymbolLt               *string           `json:"symbol_lt,omitempty"`
	SymbolLte              *string           `json:"symbol_lte,omitempty"`
	SymbolGt               *string           `json:"symbol_gt,omitempty"`
	SymbolGte              *string           `json:"symbol_gte,omitempty"`
	SymbolContains         *string           `json:"symbol_contains,omitempty"`
	SymbolNotContains      *string           `json:"symbol_not_contains,omitempty"`
	SymbolStartsWith       *string           `json:"symbol_starts_with,omitempty"`
	SymbolNotStartsWith    *string           `json:"symbol_not_starts_with,omitempty"`
	SymbolEndsWith         *string           `json:"symbol_ends_with,omitempty"`
	SymbolNotEndsWith      *string           `json:"symbol_not_ends_with,omitempty"`
	Status                 *OrderStatus      `json:"status,omitempty"`
	StatusNot              *OrderStatus      `json:"status_not,omitempty"`
	StatusIn               []OrderStatus     `json:"status_in,omitempty"`
	StatusNotIn            []OrderStatus     `json:"status_not_in,omitempty"`
	Timeframe              *string           `json:"timeframe,omitempty"`
	TimeframeNot           *string           `json:"timeframe_not,omitempty"`
	TimeframeIn            []string          `json:"timeframe_in,omitempty"`
	TimeframeNotIn         []string          `json:"timeframe_not_in,omitempty"`
	TimeframeLt            *string           `json:"timeframe_lt,omitempty"`
	TimeframeLte           *string           `json:"timeframe_lte,omitempty"`
	TimeframeGt            *string           `json:"timeframe_gt,omitempty"`
	TimeframeGte           *string           `json:"timeframe_gte,omitempty"`
	TimeframeContains      *string           `json:"timeframe_contains,omitempty"`
	TimeframeNotContains   *string           `json:"timeframe_not_contains,omitempty"`
	TimeframeStartsWith    *string           `json:"timeframe_starts_with,omitempty"`
	TimeframeNotStartsWith *string           `json:"timeframe_not_starts_with,omitempty"`
	TimeframeEndsWith      *string           `json:"timeframe_ends_with,omitempty"`
	TimeframeNotEndsWith   *string           `json:"timeframe_not_ends_with,omitempty"`
	Market                 *string           `json:"market,omitempty"`
	MarketNot              *string           `json:"market_not,omitempty"`
	MarketIn               []string          `json:"market_in,omitempty"`
	MarketNotIn            []string          `json:"market_not_in,omitempty"`
	MarketLt               *string           `json:"market_lt,omitempty"`
	MarketLte              *string           `json:"market_lte,omitempty"`
	MarketGt               *string           `json:"market_gt,omitempty"`
	MarketGte              *string           `json:"market_gte,omitempty"`
	MarketContains         *string           `json:"market_contains,omitempty"`
	MarketNotContains      *string           `json:"market_not_contains,omitempty"`
	MarketStartsWith       *string           `json:"market_starts_with,omitempty"`
	MarketNotStartsWith    *string           `json:"market_not_starts_with,omitempty"`
	MarketEndsWith         *string           `json:"market_ends_with,omitempty"`
	MarketNotEndsWith      *string           `json:"market_not_ends_with,omitempty"`
	Strategy               *string           `json:"strategy,omitempty"`
	StrategyNot            *string           `json:"strategy_not,omitempty"`
	StrategyIn             []string          `json:"strategy_in,omitempty"`
	StrategyNotIn          []string          `json:"strategy_not_in,omitempty"`
	StrategyLt             *string           `json:"strategy_lt,omitempty"`
	StrategyLte            *string           `json:"strategy_lte,omitempty"`
	StrategyGt             *string           `json:"strategy_gt,omitempty"`
	StrategyGte            *string           `json:"strategy_gte,omitempty"`
	StrategyContains       *string           `json:"strategy_contains,omitempty"`
	StrategyNotContains    *string           `json:"strategy_not_contains,omitempty"`
	StrategyStartsWith     *string           `json:"strategy_starts_with,omitempty"`
	StrategyNotStartsWith  *string           `json:"strategy_not_starts_with,omitempty"`
	StrategyEndsWith       *string           `json:"strategy_ends_with,omitempty"`
	StrategyNotEndsWith    *string           `json:"strategy_not_ends_with,omitempty"`
	CreatedAt              *string           `json:"createdAt,omitempty"`
	CreatedAtNot           *string           `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string           `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string           `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string           `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string           `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string           `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string           `json:"updatedAt_gte,omitempty"`
	And                    []OrderWhereInput `json:"AND,omitempty"`
	Or                     []OrderWhereInput `json:"OR,omitempty"`
	Not                    []OrderWhereInput `json:"NOT,omitempty"`
}

type CompanyAccountWhereInput struct {
	ID                  *string                    `json:"id,omitempty"`
	IDNot               *string                    `json:"id_not,omitempty"`
	IDIn                []string                   `json:"id_in,omitempty"`
	IDNotIn             []string                   `json:"id_not_in,omitempty"`
	IDLt                *string                    `json:"id_lt,omitempty"`
	IDLte               *string                    `json:"id_lte,omitempty"`
	IDGt                *string                    `json:"id_gt,omitempty"`
	IDGte               *string                    `json:"id_gte,omitempty"`
	IDContains          *string                    `json:"id_contains,omitempty"`
	IDNotContains       *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                    `json:"id_not_ends_with,omitempty"`
	Market              *string                    `json:"market,omitempty"`
	MarketNot           *string                    `json:"market_not,omitempty"`
	MarketIn            []string                   `json:"market_in,omitempty"`
	MarketNotIn         []string                   `json:"market_not_in,omitempty"`
	MarketLt            *string                    `json:"market_lt,omitempty"`
	MarketLte           *string                    `json:"market_lte,omitempty"`
	MarketGt            *string                    `json:"market_gt,omitempty"`
	MarketGte           *string                    `json:"market_gte,omitempty"`
	MarketContains      *string                    `json:"market_contains,omitempty"`
	MarketNotContains   *string                    `json:"market_not_contains,omitempty"`
	MarketStartsWith    *string                    `json:"market_starts_with,omitempty"`
	MarketNotStartsWith *string                    `json:"market_not_starts_with,omitempty"`
	MarketEndsWith      *string                    `json:"market_ends_with,omitempty"`
	MarketNotEndsWith   *string                    `json:"market_not_ends_with,omitempty"`
	Balance             *float64                   `json:"balance,omitempty"`
	BalanceNot          *float64                   `json:"balance_not,omitempty"`
	BalanceIn           []float64                  `json:"balance_in,omitempty"`
	BalanceNotIn        []float64                  `json:"balance_not_in,omitempty"`
	BalanceLt           *float64                   `json:"balance_lt,omitempty"`
	BalanceLte          *float64                   `json:"balance_lte,omitempty"`
	BalanceGt           *float64                   `json:"balance_gt,omitempty"`
	BalanceGte          *float64                   `json:"balance_gte,omitempty"`
	OrdersEvery         *OrderWhereInput           `json:"orders_every,omitempty"`
	OrdersSome          *OrderWhereInput           `json:"orders_some,omitempty"`
	OrdersNone          *OrderWhereInput           `json:"orders_none,omitempty"`
	CreatedAt           *string                    `json:"createdAt,omitempty"`
	CreatedAtNot        *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                    `json:"updatedAt_gte,omitempty"`
	And                 []CompanyAccountWhereInput `json:"AND,omitempty"`
	Or                  []CompanyAccountWhereInput `json:"OR,omitempty"`
	Not                 []CompanyAccountWhereInput `json:"NOT,omitempty"`
}

type FileWhereUniqueInput struct {
	ID  *string `json:"id,omitempty"`
	Url *string `json:"url,omitempty"`
}

type FileWhereInput struct {
	ID                    *string          `json:"id,omitempty"`
	IDNot                 *string          `json:"id_not,omitempty"`
	IDIn                  []string         `json:"id_in,omitempty"`
	IDNotIn               []string         `json:"id_not_in,omitempty"`
	IDLt                  *string          `json:"id_lt,omitempty"`
	IDLte                 *string          `json:"id_lte,omitempty"`
	IDGt                  *string          `json:"id_gt,omitempty"`
	IDGte                 *string          `json:"id_gte,omitempty"`
	IDContains            *string          `json:"id_contains,omitempty"`
	IDNotContains         *string          `json:"id_not_contains,omitempty"`
	IDStartsWith          *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string          `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string          `json:"createdAt,omitempty"`
	CreatedAtNot          *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string          `json:"updatedAt_gte,omitempty"`
	Filename              *string          `json:"filename,omitempty"`
	FilenameNot           *string          `json:"filename_not,omitempty"`
	FilenameIn            []string         `json:"filename_in,omitempty"`
	FilenameNotIn         []string         `json:"filename_not_in,omitempty"`
	FilenameLt            *string          `json:"filename_lt,omitempty"`
	FilenameLte           *string          `json:"filename_lte,omitempty"`
	FilenameGt            *string          `json:"filename_gt,omitempty"`
	FilenameGte           *string          `json:"filename_gte,omitempty"`
	FilenameContains      *string          `json:"filename_contains,omitempty"`
	FilenameNotContains   *string          `json:"filename_not_contains,omitempty"`
	FilenameStartsWith    *string          `json:"filename_starts_with,omitempty"`
	FilenameNotStartsWith *string          `json:"filename_not_starts_with,omitempty"`
	FilenameEndsWith      *string          `json:"filename_ends_with,omitempty"`
	FilenameNotEndsWith   *string          `json:"filename_not_ends_with,omitempty"`
	Mimetype              *string          `json:"mimetype,omitempty"`
	MimetypeNot           *string          `json:"mimetype_not,omitempty"`
	MimetypeIn            []string         `json:"mimetype_in,omitempty"`
	MimetypeNotIn         []string         `json:"mimetype_not_in,omitempty"`
	MimetypeLt            *string          `json:"mimetype_lt,omitempty"`
	MimetypeLte           *string          `json:"mimetype_lte,omitempty"`
	MimetypeGt            *string          `json:"mimetype_gt,omitempty"`
	MimetypeGte           *string          `json:"mimetype_gte,omitempty"`
	MimetypeContains      *string          `json:"mimetype_contains,omitempty"`
	MimetypeNotContains   *string          `json:"mimetype_not_contains,omitempty"`
	MimetypeStartsWith    *string          `json:"mimetype_starts_with,omitempty"`
	MimetypeNotStartsWith *string          `json:"mimetype_not_starts_with,omitempty"`
	MimetypeEndsWith      *string          `json:"mimetype_ends_with,omitempty"`
	MimetypeNotEndsWith   *string          `json:"mimetype_not_ends_with,omitempty"`
	Encoding              *string          `json:"encoding,omitempty"`
	EncodingNot           *string          `json:"encoding_not,omitempty"`
	EncodingIn            []string         `json:"encoding_in,omitempty"`
	EncodingNotIn         []string         `json:"encoding_not_in,omitempty"`
	EncodingLt            *string          `json:"encoding_lt,omitempty"`
	EncodingLte           *string          `json:"encoding_lte,omitempty"`
	EncodingGt            *string          `json:"encoding_gt,omitempty"`
	EncodingGte           *string          `json:"encoding_gte,omitempty"`
	EncodingContains      *string          `json:"encoding_contains,omitempty"`
	EncodingNotContains   *string          `json:"encoding_not_contains,omitempty"`
	EncodingStartsWith    *string          `json:"encoding_starts_with,omitempty"`
	EncodingNotStartsWith *string          `json:"encoding_not_starts_with,omitempty"`
	EncodingEndsWith      *string          `json:"encoding_ends_with,omitempty"`
	EncodingNotEndsWith   *string          `json:"encoding_not_ends_with,omitempty"`
	Url                   *string          `json:"url,omitempty"`
	UrlNot                *string          `json:"url_not,omitempty"`
	UrlIn                 []string         `json:"url_in,omitempty"`
	UrlNotIn              []string         `json:"url_not_in,omitempty"`
	UrlLt                 *string          `json:"url_lt,omitempty"`
	UrlLte                *string          `json:"url_lte,omitempty"`
	UrlGt                 *string          `json:"url_gt,omitempty"`
	UrlGte                *string          `json:"url_gte,omitempty"`
	UrlContains           *string          `json:"url_contains,omitempty"`
	UrlNotContains        *string          `json:"url_not_contains,omitempty"`
	UrlStartsWith         *string          `json:"url_starts_with,omitempty"`
	UrlNotStartsWith      *string          `json:"url_not_starts_with,omitempty"`
	UrlEndsWith           *string          `json:"url_ends_with,omitempty"`
	UrlNotEndsWith        *string          `json:"url_not_ends_with,omitempty"`
	And                   []FileWhereInput `json:"AND,omitempty"`
	Or                    []FileWhereInput `json:"OR,omitempty"`
	Not                   []FileWhereInput `json:"NOT,omitempty"`
}

type OrderWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TransactionWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TransactionWhereInput struct {
	ID                    *string                   `json:"id,omitempty"`
	IDNot                 *string                   `json:"id_not,omitempty"`
	IDIn                  []string                  `json:"id_in,omitempty"`
	IDNotIn               []string                  `json:"id_not_in,omitempty"`
	IDLt                  *string                   `json:"id_lt,omitempty"`
	IDLte                 *string                   `json:"id_lte,omitempty"`
	IDGt                  *string                   `json:"id_gt,omitempty"`
	IDGte                 *string                   `json:"id_gte,omitempty"`
	IDContains            *string                   `json:"id_contains,omitempty"`
	IDNotContains         *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                   `json:"id_not_ends_with,omitempty"`
	Currency              *string                   `json:"currency,omitempty"`
	CurrencyNot           *string                   `json:"currency_not,omitempty"`
	CurrencyIn            []string                  `json:"currency_in,omitempty"`
	CurrencyNotIn         []string                  `json:"currency_not_in,omitempty"`
	CurrencyLt            *string                   `json:"currency_lt,omitempty"`
	CurrencyLte           *string                   `json:"currency_lte,omitempty"`
	CurrencyGt            *string                   `json:"currency_gt,omitempty"`
	CurrencyGte           *string                   `json:"currency_gte,omitempty"`
	CurrencyContains      *string                   `json:"currency_contains,omitempty"`
	CurrencyNotContains   *string                   `json:"currency_not_contains,omitempty"`
	CurrencyStartsWith    *string                   `json:"currency_starts_with,omitempty"`
	CurrencyNotStartsWith *string                   `json:"currency_not_starts_with,omitempty"`
	CurrencyEndsWith      *string                   `json:"currency_ends_with,omitempty"`
	CurrencyNotEndsWith   *string                   `json:"currency_not_ends_with,omitempty"`
	Amount                *float64                  `json:"amount,omitempty"`
	AmountNot             *float64                  `json:"amount_not,omitempty"`
	AmountIn              []float64                 `json:"amount_in,omitempty"`
	AmountNotIn           []float64                 `json:"amount_not_in,omitempty"`
	AmountLt              *float64                  `json:"amount_lt,omitempty"`
	AmountLte             *float64                  `json:"amount_lte,omitempty"`
	AmountGt              *float64                  `json:"amount_gt,omitempty"`
	AmountGte             *float64                  `json:"amount_gte,omitempty"`
	Type                  *TransactionType          `json:"type,omitempty"`
	TypeNot               *TransactionType          `json:"type_not,omitempty"`
	TypeIn                []TransactionType         `json:"type_in,omitempty"`
	TypeNotIn             []TransactionType         `json:"type_not_in,omitempty"`
	Status                *DepositWithdrawalStatus  `json:"status,omitempty"`
	StatusNot             *DepositWithdrawalStatus  `json:"status_not,omitempty"`
	StatusIn              []DepositWithdrawalStatus `json:"status_in,omitempty"`
	StatusNotIn           []DepositWithdrawalStatus `json:"status_not_in,omitempty"`
	CreatedAt             *string                   `json:"createdAt,omitempty"`
	CreatedAtNot          *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                   `json:"updatedAt_gte,omitempty"`
	And                   []TransactionWhereInput   `json:"AND,omitempty"`
	Or                    []TransactionWhereInput   `json:"OR,omitempty"`
	Not                   []TransactionWhereInput   `json:"NOT,omitempty"`
}

type UserWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	Email    *string `json:"email,omitempty"`
	Username *string `json:"username,omitempty"`
	Nric     *string `json:"nric,omitempty"`
}

type UserRoleWhereInput struct {
	ID                      *string              `json:"id,omitempty"`
	IDNot                   *string              `json:"id_not,omitempty"`
	IDIn                    []string             `json:"id_in,omitempty"`
	IDNotIn                 []string             `json:"id_not_in,omitempty"`
	IDLt                    *string              `json:"id_lt,omitempty"`
	IDLte                   *string              `json:"id_lte,omitempty"`
	IDGt                    *string              `json:"id_gt,omitempty"`
	IDGte                   *string              `json:"id_gte,omitempty"`
	IDContains              *string              `json:"id_contains,omitempty"`
	IDNotContains           *string              `json:"id_not_contains,omitempty"`
	IDStartsWith            *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string              `json:"id_not_ends_with,omitempty"`
	Namespace               *RoleNamespace       `json:"namespace,omitempty"`
	NamespaceNot            *RoleNamespace       `json:"namespace_not,omitempty"`
	NamespaceIn             []RoleNamespace      `json:"namespace_in,omitempty"`
	NamespaceNotIn          []RoleNamespace      `json:"namespace_not_in,omitempty"`
	Permission              *string              `json:"permission,omitempty"`
	PermissionNot           *string              `json:"permission_not,omitempty"`
	PermissionIn            []string             `json:"permission_in,omitempty"`
	PermissionNotIn         []string             `json:"permission_not_in,omitempty"`
	PermissionLt            *string              `json:"permission_lt,omitempty"`
	PermissionLte           *string              `json:"permission_lte,omitempty"`
	PermissionGt            *string              `json:"permission_gt,omitempty"`
	PermissionGte           *string              `json:"permission_gte,omitempty"`
	PermissionContains      *string              `json:"permission_contains,omitempty"`
	PermissionNotContains   *string              `json:"permission_not_contains,omitempty"`
	PermissionStartsWith    *string              `json:"permission_starts_with,omitempty"`
	PermissionNotStartsWith *string              `json:"permission_not_starts_with,omitempty"`
	PermissionEndsWith      *string              `json:"permission_ends_with,omitempty"`
	PermissionNotEndsWith   *string              `json:"permission_not_ends_with,omitempty"`
	And                     []UserRoleWhereInput `json:"AND,omitempty"`
	Or                      []UserRoleWhereInput `json:"OR,omitempty"`
	Not                     []UserRoleWhereInput `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                    *string                `json:"id,omitempty"`
	IDNot                 *string                `json:"id_not,omitempty"`
	IDIn                  []string               `json:"id_in,omitempty"`
	IDNotIn               []string               `json:"id_not_in,omitempty"`
	IDLt                  *string                `json:"id_lt,omitempty"`
	IDLte                 *string                `json:"id_lte,omitempty"`
	IDGt                  *string                `json:"id_gt,omitempty"`
	IDGte                 *string                `json:"id_gte,omitempty"`
	IDContains            *string                `json:"id_contains,omitempty"`
	IDNotContains         *string                `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                `json:"id_not_ends_with,omitempty"`
	Email                 *string                `json:"email,omitempty"`
	EmailNot              *string                `json:"email_not,omitempty"`
	EmailIn               []string               `json:"email_in,omitempty"`
	EmailNotIn            []string               `json:"email_not_in,omitempty"`
	EmailLt               *string                `json:"email_lt,omitempty"`
	EmailLte              *string                `json:"email_lte,omitempty"`
	EmailGt               *string                `json:"email_gt,omitempty"`
	EmailGte              *string                `json:"email_gte,omitempty"`
	EmailContains         *string                `json:"email_contains,omitempty"`
	EmailNotContains      *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string                `json:"email_not_ends_with,omitempty"`
	Password              *string                `json:"password,omitempty"`
	PasswordNot           *string                `json:"password_not,omitempty"`
	PasswordIn            []string               `json:"password_in,omitempty"`
	PasswordNotIn         []string               `json:"password_not_in,omitempty"`
	PasswordLt            *string                `json:"password_lt,omitempty"`
	PasswordLte           *string                `json:"password_lte,omitempty"`
	PasswordGt            *string                `json:"password_gt,omitempty"`
	PasswordGte           *string                `json:"password_gte,omitempty"`
	PasswordContains      *string                `json:"password_contains,omitempty"`
	PasswordNotContains   *string                `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string                `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string                `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string                `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string                `json:"password_not_ends_with,omitempty"`
	EmailVerified         *bool                  `json:"emailVerified,omitempty"`
	EmailVerifiedNot      *bool                  `json:"emailVerified_not,omitempty"`
	Username              *string                `json:"username,omitempty"`
	UsernameNot           *string                `json:"username_not,omitempty"`
	UsernameIn            []string               `json:"username_in,omitempty"`
	UsernameNotIn         []string               `json:"username_not_in,omitempty"`
	UsernameLt            *string                `json:"username_lt,omitempty"`
	UsernameLte           *string                `json:"username_lte,omitempty"`
	UsernameGt            *string                `json:"username_gt,omitempty"`
	UsernameGte           *string                `json:"username_gte,omitempty"`
	UsernameContains      *string                `json:"username_contains,omitempty"`
	UsernameNotContains   *string                `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string                `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string                `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string                `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string                `json:"username_not_ends_with,omitempty"`
	Nric                  *string                `json:"nric,omitempty"`
	NricNot               *string                `json:"nric_not,omitempty"`
	NricIn                []string               `json:"nric_in,omitempty"`
	NricNotIn             []string               `json:"nric_not_in,omitempty"`
	NricLt                *string                `json:"nric_lt,omitempty"`
	NricLte               *string                `json:"nric_lte,omitempty"`
	NricGt                *string                `json:"nric_gt,omitempty"`
	NricGte               *string                `json:"nric_gte,omitempty"`
	NricContains          *string                `json:"nric_contains,omitempty"`
	NricNotContains       *string                `json:"nric_not_contains,omitempty"`
	NricStartsWith        *string                `json:"nric_starts_with,omitempty"`
	NricNotStartsWith     *string                `json:"nric_not_starts_with,omitempty"`
	NricEndsWith          *string                `json:"nric_ends_with,omitempty"`
	NricNotEndsWith       *string                `json:"nric_not_ends_with,omitempty"`
	Profile               *UserProfileWhereInput `json:"profile,omitempty"`
	RolesEvery            *UserRoleWhereInput    `json:"roles_every,omitempty"`
	RolesSome             *UserRoleWhereInput    `json:"roles_some,omitempty"`
	RolesNone             *UserRoleWhereInput    `json:"roles_none,omitempty"`
	Wallet                *WalletWhereInput      `json:"wallet,omitempty"`
	CreatedAt             *string                `json:"createdAt,omitempty"`
	CreatedAtNot          *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                `json:"updatedAt_gte,omitempty"`
	And                   []UserWhereInput       `json:"AND,omitempty"`
	Or                    []UserWhereInput       `json:"OR,omitempty"`
	Not                   []UserWhereInput       `json:"NOT,omitempty"`
}

type UserProfileWhereInput struct {
	ID                        *string                 `json:"id,omitempty"`
	IDNot                     *string                 `json:"id_not,omitempty"`
	IDIn                      []string                `json:"id_in,omitempty"`
	IDNotIn                   []string                `json:"id_not_in,omitempty"`
	IDLt                      *string                 `json:"id_lt,omitempty"`
	IDLte                     *string                 `json:"id_lte,omitempty"`
	IDGt                      *string                 `json:"id_gt,omitempty"`
	IDGte                     *string                 `json:"id_gte,omitempty"`
	IDContains                *string                 `json:"id_contains,omitempty"`
	IDNotContains             *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                 `json:"id_not_ends_with,omitempty"`
	Address                   *string                 `json:"address,omitempty"`
	AddressNot                *string                 `json:"address_not,omitempty"`
	AddressIn                 []string                `json:"address_in,omitempty"`
	AddressNotIn              []string                `json:"address_not_in,omitempty"`
	AddressLt                 *string                 `json:"address_lt,omitempty"`
	AddressLte                *string                 `json:"address_lte,omitempty"`
	AddressGt                 *string                 `json:"address_gt,omitempty"`
	AddressGte                *string                 `json:"address_gte,omitempty"`
	AddressContains           *string                 `json:"address_contains,omitempty"`
	AddressNotContains        *string                 `json:"address_not_contains,omitempty"`
	AddressStartsWith         *string                 `json:"address_starts_with,omitempty"`
	AddressNotStartsWith      *string                 `json:"address_not_starts_with,omitempty"`
	AddressEndsWith           *string                 `json:"address_ends_with,omitempty"`
	AddressNotEndsWith        *string                 `json:"address_not_ends_with,omitempty"`
	Age                       *string                 `json:"age,omitempty"`
	AgeNot                    *string                 `json:"age_not,omitempty"`
	AgeIn                     []string                `json:"age_in,omitempty"`
	AgeNotIn                  []string                `json:"age_not_in,omitempty"`
	AgeLt                     *string                 `json:"age_lt,omitempty"`
	AgeLte                    *string                 `json:"age_lte,omitempty"`
	AgeGt                     *string                 `json:"age_gt,omitempty"`
	AgeGte                    *string                 `json:"age_gte,omitempty"`
	AgeContains               *string                 `json:"age_contains,omitempty"`
	AgeNotContains            *string                 `json:"age_not_contains,omitempty"`
	AgeStartsWith             *string                 `json:"age_starts_with,omitempty"`
	AgeNotStartsWith          *string                 `json:"age_not_starts_with,omitempty"`
	AgeEndsWith               *string                 `json:"age_ends_with,omitempty"`
	AgeNotEndsWith            *string                 `json:"age_not_ends_with,omitempty"`
	Citizenship               *string                 `json:"citizenship,omitempty"`
	CitizenshipNot            *string                 `json:"citizenship_not,omitempty"`
	CitizenshipIn             []string                `json:"citizenship_in,omitempty"`
	CitizenshipNotIn          []string                `json:"citizenship_not_in,omitempty"`
	CitizenshipLt             *string                 `json:"citizenship_lt,omitempty"`
	CitizenshipLte            *string                 `json:"citizenship_lte,omitempty"`
	CitizenshipGt             *string                 `json:"citizenship_gt,omitempty"`
	CitizenshipGte            *string                 `json:"citizenship_gte,omitempty"`
	CitizenshipContains       *string                 `json:"citizenship_contains,omitempty"`
	CitizenshipNotContains    *string                 `json:"citizenship_not_contains,omitempty"`
	CitizenshipStartsWith     *string                 `json:"citizenship_starts_with,omitempty"`
	CitizenshipNotStartsWith  *string                 `json:"citizenship_not_starts_with,omitempty"`
	CitizenshipEndsWith       *string                 `json:"citizenship_ends_with,omitempty"`
	CitizenshipNotEndsWith    *string                 `json:"citizenship_not_ends_with,omitempty"`
	Country                   *string                 `json:"country,omitempty"`
	CountryNot                *string                 `json:"country_not,omitempty"`
	CountryIn                 []string                `json:"country_in,omitempty"`
	CountryNotIn              []string                `json:"country_not_in,omitempty"`
	CountryLt                 *string                 `json:"country_lt,omitempty"`
	CountryLte                *string                 `json:"country_lte,omitempty"`
	CountryGt                 *string                 `json:"country_gt,omitempty"`
	CountryGte                *string                 `json:"country_gte,omitempty"`
	CountryContains           *string                 `json:"country_contains,omitempty"`
	CountryNotContains        *string                 `json:"country_not_contains,omitempty"`
	CountryStartsWith         *string                 `json:"country_starts_with,omitempty"`
	CountryNotStartsWith      *string                 `json:"country_not_starts_with,omitempty"`
	CountryEndsWith           *string                 `json:"country_ends_with,omitempty"`
	CountryNotEndsWith        *string                 `json:"country_not_ends_with,omitempty"`
	DateOfBirth               *string                 `json:"dateOfBirth,omitempty"`
	DateOfBirthNot            *string                 `json:"dateOfBirth_not,omitempty"`
	DateOfBirthIn             []string                `json:"dateOfBirth_in,omitempty"`
	DateOfBirthNotIn          []string                `json:"dateOfBirth_not_in,omitempty"`
	DateOfBirthLt             *string                 `json:"dateOfBirth_lt,omitempty"`
	DateOfBirthLte            *string                 `json:"dateOfBirth_lte,omitempty"`
	DateOfBirthGt             *string                 `json:"dateOfBirth_gt,omitempty"`
	DateOfBirthGte            *string                 `json:"dateOfBirth_gte,omitempty"`
	FullName                  *string                 `json:"fullName,omitempty"`
	FullNameNot               *string                 `json:"fullName_not,omitempty"`
	FullNameIn                []string                `json:"fullName_in,omitempty"`
	FullNameNotIn             []string                `json:"fullName_not_in,omitempty"`
	FullNameLt                *string                 `json:"fullName_lt,omitempty"`
	FullNameLte               *string                 `json:"fullName_lte,omitempty"`
	FullNameGt                *string                 `json:"fullName_gt,omitempty"`
	FullNameGte               *string                 `json:"fullName_gte,omitempty"`
	FullNameContains          *string                 `json:"fullName_contains,omitempty"`
	FullNameNotContains       *string                 `json:"fullName_not_contains,omitempty"`
	FullNameStartsWith        *string                 `json:"fullName_starts_with,omitempty"`
	FullNameNotStartsWith     *string                 `json:"fullName_not_starts_with,omitempty"`
	FullNameEndsWith          *string                 `json:"fullName_ends_with,omitempty"`
	FullNameNotEndsWith       *string                 `json:"fullName_not_ends_with,omitempty"`
	Occupation                *string                 `json:"occupation,omitempty"`
	OccupationNot             *string                 `json:"occupation_not,omitempty"`
	OccupationIn              []string                `json:"occupation_in,omitempty"`
	OccupationNotIn           []string                `json:"occupation_not_in,omitempty"`
	OccupationLt              *string                 `json:"occupation_lt,omitempty"`
	OccupationLte             *string                 `json:"occupation_lte,omitempty"`
	OccupationGt              *string                 `json:"occupation_gt,omitempty"`
	OccupationGte             *string                 `json:"occupation_gte,omitempty"`
	OccupationContains        *string                 `json:"occupation_contains,omitempty"`
	OccupationNotContains     *string                 `json:"occupation_not_contains,omitempty"`
	OccupationStartsWith      *string                 `json:"occupation_starts_with,omitempty"`
	OccupationNotStartsWith   *string                 `json:"occupation_not_starts_with,omitempty"`
	OccupationEndsWith        *string                 `json:"occupation_ends_with,omitempty"`
	OccupationNotEndsWith     *string                 `json:"occupation_not_ends_with,omitempty"`
	Organisation              *string                 `json:"organisation,omitempty"`
	OrganisationNot           *string                 `json:"organisation_not,omitempty"`
	OrganisationIn            []string                `json:"organisation_in,omitempty"`
	OrganisationNotIn         []string                `json:"organisation_not_in,omitempty"`
	OrganisationLt            *string                 `json:"organisation_lt,omitempty"`
	OrganisationLte           *string                 `json:"organisation_lte,omitempty"`
	OrganisationGt            *string                 `json:"organisation_gt,omitempty"`
	OrganisationGte           *string                 `json:"organisation_gte,omitempty"`
	OrganisationContains      *string                 `json:"organisation_contains,omitempty"`
	OrganisationNotContains   *string                 `json:"organisation_not_contains,omitempty"`
	OrganisationStartsWith    *string                 `json:"organisation_starts_with,omitempty"`
	OrganisationNotStartsWith *string                 `json:"organisation_not_starts_with,omitempty"`
	OrganisationEndsWith      *string                 `json:"organisation_ends_with,omitempty"`
	OrganisationNotEndsWith   *string                 `json:"organisation_not_ends_with,omitempty"`
	Phone                     *string                 `json:"phone,omitempty"`
	PhoneNot                  *string                 `json:"phone_not,omitempty"`
	PhoneIn                   []string                `json:"phone_in,omitempty"`
	PhoneNotIn                []string                `json:"phone_not_in,omitempty"`
	PhoneLt                   *string                 `json:"phone_lt,omitempty"`
	PhoneLte                  *string                 `json:"phone_lte,omitempty"`
	PhoneGt                   *string                 `json:"phone_gt,omitempty"`
	PhoneGte                  *string                 `json:"phone_gte,omitempty"`
	PhoneContains             *string                 `json:"phone_contains,omitempty"`
	PhoneNotContains          *string                 `json:"phone_not_contains,omitempty"`
	PhoneStartsWith           *string                 `json:"phone_starts_with,omitempty"`
	PhoneNotStartsWith        *string                 `json:"phone_not_starts_with,omitempty"`
	PhoneEndsWith             *string                 `json:"phone_ends_with,omitempty"`
	PhoneNotEndsWith          *string                 `json:"phone_not_ends_with,omitempty"`
	And                       []UserProfileWhereInput `json:"AND,omitempty"`
	Or                        []UserProfileWhereInput `json:"OR,omitempty"`
	Not                       []UserProfileWhereInput `json:"NOT,omitempty"`
}

type WalletWhereInput struct {
	ID                *string                `json:"id,omitempty"`
	IDNot             *string                `json:"id_not,omitempty"`
	IDIn              []string               `json:"id_in,omitempty"`
	IDNotIn           []string               `json:"id_not_in,omitempty"`
	IDLt              *string                `json:"id_lt,omitempty"`
	IDLte             *string                `json:"id_lte,omitempty"`
	IDGt              *string                `json:"id_gt,omitempty"`
	IDGte             *string                `json:"id_gte,omitempty"`
	IDContains        *string                `json:"id_contains,omitempty"`
	IDNotContains     *string                `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                `json:"id_not_ends_with,omitempty"`
	Balance           *float64               `json:"balance,omitempty"`
	BalanceNot        *float64               `json:"balance_not,omitempty"`
	BalanceIn         []float64              `json:"balance_in,omitempty"`
	BalanceNotIn      []float64              `json:"balance_not_in,omitempty"`
	BalanceLt         *float64               `json:"balance_lt,omitempty"`
	BalanceLte        *float64               `json:"balance_lte,omitempty"`
	BalanceGt         *float64               `json:"balance_gt,omitempty"`
	BalanceGte        *float64               `json:"balance_gte,omitempty"`
	TransactionsEvery *TransactionWhereInput `json:"transactions_every,omitempty"`
	TransactionsSome  *TransactionWhereInput `json:"transactions_some,omitempty"`
	TransactionsNone  *TransactionWhereInput `json:"transactions_none,omitempty"`
	CreatedAt         *string                `json:"createdAt,omitempty"`
	CreatedAtNot      *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                `json:"updatedAt_gte,omitempty"`
	And               []WalletWhereInput     `json:"AND,omitempty"`
	Or                []WalletWhereInput     `json:"OR,omitempty"`
	Not               []WalletWhereInput     `json:"NOT,omitempty"`
}

type UserProfileWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserRoleWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type WalletWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CompanyAccountCreateInput struct {
	ID      *string               `json:"id,omitempty"`
	Market  *string               `json:"market,omitempty"`
	Balance *float64              `json:"balance,omitempty"`
	Orders  *OrderCreateManyInput `json:"orders,omitempty"`
}

type OrderCreateManyInput struct {
	Create  []OrderCreateInput      `json:"create,omitempty"`
	Connect []OrderWhereUniqueInput `json:"connect,omitempty"`
}

type OrderCreateInput struct {
	ID        *string     `json:"id,omitempty"`
	Type      string      `json:"type"`
	Price     float64     `json:"price"`
	ExitPrice *float64    `json:"exitPrice,omitempty"`
	Amount    float64     `json:"amount"`
	Symbol    string      `json:"symbol"`
	Status    OrderStatus `json:"status"`
	Timeframe string      `json:"timeframe"`
	Market    string      `json:"market"`
	Strategy  string      `json:"strategy"`
}

type CompanyAccountUpdateInput struct {
	Market  *string               `json:"market,omitempty"`
	Balance *float64              `json:"balance,omitempty"`
	Orders  *OrderUpdateManyInput `json:"orders,omitempty"`
}

type OrderUpdateManyInput struct {
	Create     []OrderCreateInput                      `json:"create,omitempty"`
	Update     []OrderUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []OrderUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []OrderWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []OrderWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []OrderWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []OrderWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []OrderScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []OrderUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type OrderUpdateWithWhereUniqueNestedInput struct {
	Where OrderWhereUniqueInput `json:"where"`
	Data  OrderUpdateDataInput  `json:"data"`
}

type OrderUpdateDataInput struct {
	Type      *string      `json:"type,omitempty"`
	Price     *float64     `json:"price,omitempty"`
	ExitPrice *float64     `json:"exitPrice,omitempty"`
	Amount    *float64     `json:"amount,omitempty"`
	Symbol    *string      `json:"symbol,omitempty"`
	Status    *OrderStatus `json:"status,omitempty"`
	Timeframe *string      `json:"timeframe,omitempty"`
	Market    *string      `json:"market,omitempty"`
	Strategy  *string      `json:"strategy,omitempty"`
}

type OrderUpsertWithWhereUniqueNestedInput struct {
	Where  OrderWhereUniqueInput `json:"where"`
	Update OrderUpdateDataInput  `json:"update"`
	Create OrderCreateInput      `json:"create"`
}

type OrderScalarWhereInput struct {
	ID                     *string                 `json:"id,omitempty"`
	IDNot                  *string                 `json:"id_not,omitempty"`
	IDIn                   []string                `json:"id_in,omitempty"`
	IDNotIn                []string                `json:"id_not_in,omitempty"`
	IDLt                   *string                 `json:"id_lt,omitempty"`
	IDLte                  *string                 `json:"id_lte,omitempty"`
	IDGt                   *string                 `json:"id_gt,omitempty"`
	IDGte                  *string                 `json:"id_gte,omitempty"`
	IDContains             *string                 `json:"id_contains,omitempty"`
	IDNotContains          *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                 `json:"id_not_ends_with,omitempty"`
	Type                   *string                 `json:"type,omitempty"`
	TypeNot                *string                 `json:"type_not,omitempty"`
	TypeIn                 []string                `json:"type_in,omitempty"`
	TypeNotIn              []string                `json:"type_not_in,omitempty"`
	TypeLt                 *string                 `json:"type_lt,omitempty"`
	TypeLte                *string                 `json:"type_lte,omitempty"`
	TypeGt                 *string                 `json:"type_gt,omitempty"`
	TypeGte                *string                 `json:"type_gte,omitempty"`
	TypeContains           *string                 `json:"type_contains,omitempty"`
	TypeNotContains        *string                 `json:"type_not_contains,omitempty"`
	TypeStartsWith         *string                 `json:"type_starts_with,omitempty"`
	TypeNotStartsWith      *string                 `json:"type_not_starts_with,omitempty"`
	TypeEndsWith           *string                 `json:"type_ends_with,omitempty"`
	TypeNotEndsWith        *string                 `json:"type_not_ends_with,omitempty"`
	Price                  *float64                `json:"price,omitempty"`
	PriceNot               *float64                `json:"price_not,omitempty"`
	PriceIn                []float64               `json:"price_in,omitempty"`
	PriceNotIn             []float64               `json:"price_not_in,omitempty"`
	PriceLt                *float64                `json:"price_lt,omitempty"`
	PriceLte               *float64                `json:"price_lte,omitempty"`
	PriceGt                *float64                `json:"price_gt,omitempty"`
	PriceGte               *float64                `json:"price_gte,omitempty"`
	ExitPrice              *float64                `json:"exitPrice,omitempty"`
	ExitPriceNot           *float64                `json:"exitPrice_not,omitempty"`
	ExitPriceIn            []float64               `json:"exitPrice_in,omitempty"`
	ExitPriceNotIn         []float64               `json:"exitPrice_not_in,omitempty"`
	ExitPriceLt            *float64                `json:"exitPrice_lt,omitempty"`
	ExitPriceLte           *float64                `json:"exitPrice_lte,omitempty"`
	ExitPriceGt            *float64                `json:"exitPrice_gt,omitempty"`
	ExitPriceGte           *float64                `json:"exitPrice_gte,omitempty"`
	Amount                 *float64                `json:"amount,omitempty"`
	AmountNot              *float64                `json:"amount_not,omitempty"`
	AmountIn               []float64               `json:"amount_in,omitempty"`
	AmountNotIn            []float64               `json:"amount_not_in,omitempty"`
	AmountLt               *float64                `json:"amount_lt,omitempty"`
	AmountLte              *float64                `json:"amount_lte,omitempty"`
	AmountGt               *float64                `json:"amount_gt,omitempty"`
	AmountGte              *float64                `json:"amount_gte,omitempty"`
	Symbol                 *string                 `json:"symbol,omitempty"`
	SymbolNot              *string                 `json:"symbol_not,omitempty"`
	SymbolIn               []string                `json:"symbol_in,omitempty"`
	SymbolNotIn            []string                `json:"symbol_not_in,omitempty"`
	SymbolLt               *string                 `json:"symbol_lt,omitempty"`
	SymbolLte              *string                 `json:"symbol_lte,omitempty"`
	SymbolGt               *string                 `json:"symbol_gt,omitempty"`
	SymbolGte              *string                 `json:"symbol_gte,omitempty"`
	SymbolContains         *string                 `json:"symbol_contains,omitempty"`
	SymbolNotContains      *string                 `json:"symbol_not_contains,omitempty"`
	SymbolStartsWith       *string                 `json:"symbol_starts_with,omitempty"`
	SymbolNotStartsWith    *string                 `json:"symbol_not_starts_with,omitempty"`
	SymbolEndsWith         *string                 `json:"symbol_ends_with,omitempty"`
	SymbolNotEndsWith      *string                 `json:"symbol_not_ends_with,omitempty"`
	Status                 *OrderStatus            `json:"status,omitempty"`
	StatusNot              *OrderStatus            `json:"status_not,omitempty"`
	StatusIn               []OrderStatus           `json:"status_in,omitempty"`
	StatusNotIn            []OrderStatus           `json:"status_not_in,omitempty"`
	Timeframe              *string                 `json:"timeframe,omitempty"`
	TimeframeNot           *string                 `json:"timeframe_not,omitempty"`
	TimeframeIn            []string                `json:"timeframe_in,omitempty"`
	TimeframeNotIn         []string                `json:"timeframe_not_in,omitempty"`
	TimeframeLt            *string                 `json:"timeframe_lt,omitempty"`
	TimeframeLte           *string                 `json:"timeframe_lte,omitempty"`
	TimeframeGt            *string                 `json:"timeframe_gt,omitempty"`
	TimeframeGte           *string                 `json:"timeframe_gte,omitempty"`
	TimeframeContains      *string                 `json:"timeframe_contains,omitempty"`
	TimeframeNotContains   *string                 `json:"timeframe_not_contains,omitempty"`
	TimeframeStartsWith    *string                 `json:"timeframe_starts_with,omitempty"`
	TimeframeNotStartsWith *string                 `json:"timeframe_not_starts_with,omitempty"`
	TimeframeEndsWith      *string                 `json:"timeframe_ends_with,omitempty"`
	TimeframeNotEndsWith   *string                 `json:"timeframe_not_ends_with,omitempty"`
	Market                 *string                 `json:"market,omitempty"`
	MarketNot              *string                 `json:"market_not,omitempty"`
	MarketIn               []string                `json:"market_in,omitempty"`
	MarketNotIn            []string                `json:"market_not_in,omitempty"`
	MarketLt               *string                 `json:"market_lt,omitempty"`
	MarketLte              *string                 `json:"market_lte,omitempty"`
	MarketGt               *string                 `json:"market_gt,omitempty"`
	MarketGte              *string                 `json:"market_gte,omitempty"`
	MarketContains         *string                 `json:"market_contains,omitempty"`
	MarketNotContains      *string                 `json:"market_not_contains,omitempty"`
	MarketStartsWith       *string                 `json:"market_starts_with,omitempty"`
	MarketNotStartsWith    *string                 `json:"market_not_starts_with,omitempty"`
	MarketEndsWith         *string                 `json:"market_ends_with,omitempty"`
	MarketNotEndsWith      *string                 `json:"market_not_ends_with,omitempty"`
	Strategy               *string                 `json:"strategy,omitempty"`
	StrategyNot            *string                 `json:"strategy_not,omitempty"`
	StrategyIn             []string                `json:"strategy_in,omitempty"`
	StrategyNotIn          []string                `json:"strategy_not_in,omitempty"`
	StrategyLt             *string                 `json:"strategy_lt,omitempty"`
	StrategyLte            *string                 `json:"strategy_lte,omitempty"`
	StrategyGt             *string                 `json:"strategy_gt,omitempty"`
	StrategyGte            *string                 `json:"strategy_gte,omitempty"`
	StrategyContains       *string                 `json:"strategy_contains,omitempty"`
	StrategyNotContains    *string                 `json:"strategy_not_contains,omitempty"`
	StrategyStartsWith     *string                 `json:"strategy_starts_with,omitempty"`
	StrategyNotStartsWith  *string                 `json:"strategy_not_starts_with,omitempty"`
	StrategyEndsWith       *string                 `json:"strategy_ends_with,omitempty"`
	StrategyNotEndsWith    *string                 `json:"strategy_not_ends_with,omitempty"`
	CreatedAt              *string                 `json:"createdAt,omitempty"`
	CreatedAtNot           *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                 `json:"updatedAt_gte,omitempty"`
	And                    []OrderScalarWhereInput `json:"AND,omitempty"`
	Or                     []OrderScalarWhereInput `json:"OR,omitempty"`
	Not                    []OrderScalarWhereInput `json:"NOT,omitempty"`
}

type OrderUpdateManyWithWhereNestedInput struct {
	Where OrderScalarWhereInput    `json:"where"`
	Data  OrderUpdateManyDataInput `json:"data"`
}

type OrderUpdateManyDataInput struct {
	Type      *string      `json:"type,omitempty"`
	Price     *float64     `json:"price,omitempty"`
	ExitPrice *float64     `json:"exitPrice,omitempty"`
	Amount    *float64     `json:"amount,omitempty"`
	Symbol    *string      `json:"symbol,omitempty"`
	Status    *OrderStatus `json:"status,omitempty"`
	Timeframe *string      `json:"timeframe,omitempty"`
	Market    *string      `json:"market,omitempty"`
	Strategy  *string      `json:"strategy,omitempty"`
}

type CompanyAccountUpdateManyMutationInput struct {
	Market  *string  `json:"market,omitempty"`
	Balance *float64 `json:"balance,omitempty"`
}

type FileCreateInput struct {
	ID       *string                 `json:"id,omitempty"`
	Filename string                  `json:"filename"`
	Mimetype string                  `json:"mimetype"`
	Encoding string                  `json:"encoding"`
	Meta     *map[string]interface{} `json:"meta,omitempty"`
	Url      string                  `json:"url"`
}

type FileUpdateInput struct {
	Filename *string                 `json:"filename,omitempty"`
	Mimetype *string                 `json:"mimetype,omitempty"`
	Encoding *string                 `json:"encoding,omitempty"`
	Meta     *map[string]interface{} `json:"meta,omitempty"`
	Url      *string                 `json:"url,omitempty"`
}

type FileUpdateManyMutationInput struct {
	Filename *string                 `json:"filename,omitempty"`
	Mimetype *string                 `json:"mimetype,omitempty"`
	Encoding *string                 `json:"encoding,omitempty"`
	Meta     *map[string]interface{} `json:"meta,omitempty"`
	Url      *string                 `json:"url,omitempty"`
}

type OrderUpdateInput struct {
	Type      *string      `json:"type,omitempty"`
	Price     *float64     `json:"price,omitempty"`
	ExitPrice *float64     `json:"exitPrice,omitempty"`
	Amount    *float64     `json:"amount,omitempty"`
	Symbol    *string      `json:"symbol,omitempty"`
	Status    *OrderStatus `json:"status,omitempty"`
	Timeframe *string      `json:"timeframe,omitempty"`
	Market    *string      `json:"market,omitempty"`
	Strategy  *string      `json:"strategy,omitempty"`
}

type OrderUpdateManyMutationInput struct {
	Type      *string      `json:"type,omitempty"`
	Price     *float64     `json:"price,omitempty"`
	ExitPrice *float64     `json:"exitPrice,omitempty"`
	Amount    *float64     `json:"amount,omitempty"`
	Symbol    *string      `json:"symbol,omitempty"`
	Status    *OrderStatus `json:"status,omitempty"`
	Timeframe *string      `json:"timeframe,omitempty"`
	Market    *string      `json:"market,omitempty"`
	Strategy  *string      `json:"strategy,omitempty"`
}

type TransactionCreateInput struct {
	ID       *string                  `json:"id,omitempty"`
	Currency string                   `json:"currency"`
	Amount   float64                  `json:"amount"`
	Type     TransactionType          `json:"type"`
	Status   *DepositWithdrawalStatus `json:"status,omitempty"`
}

type TransactionUpdateInput struct {
	Currency *string                  `json:"currency,omitempty"`
	Amount   *float64                 `json:"amount,omitempty"`
	Type     *TransactionType         `json:"type,omitempty"`
	Status   *DepositWithdrawalStatus `json:"status,omitempty"`
}

type TransactionUpdateManyMutationInput struct {
	Currency *string                  `json:"currency,omitempty"`
	Amount   *float64                 `json:"amount,omitempty"`
	Type     *TransactionType         `json:"type,omitempty"`
	Status   *DepositWithdrawalStatus `json:"status,omitempty"`
}

type UserCreateInput struct {
	ID            *string                   `json:"id,omitempty"`
	Email         string                    `json:"email"`
	Password      string                    `json:"password"`
	EmailVerified *bool                     `json:"emailVerified,omitempty"`
	Username      *string                   `json:"username,omitempty"`
	Nric          *string                   `json:"nric,omitempty"`
	Profile       UserProfileCreateOneInput `json:"profile"`
	Roles         *UserRoleCreateManyInput  `json:"roles,omitempty"`
	Wallet        WalletCreateOneInput      `json:"wallet"`
}

type UserProfileCreateOneInput struct {
	Create  *UserProfileCreateInput      `json:"create,omitempty"`
	Connect *UserProfileWhereUniqueInput `json:"connect,omitempty"`
}

type UserProfileCreateInput struct {
	ID           *string `json:"id,omitempty"`
	Address      *string `json:"address,omitempty"`
	Age          *string `json:"age,omitempty"`
	Citizenship  *string `json:"citizenship,omitempty"`
	Country      *string `json:"country,omitempty"`
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	FullName     *string `json:"fullName,omitempty"`
	Occupation   *string `json:"occupation,omitempty"`
	Organisation *string `json:"organisation,omitempty"`
	Phone        *string `json:"phone,omitempty"`
}

type UserRoleCreateManyInput struct {
	Create  []UserRoleCreateInput      `json:"create,omitempty"`
	Connect []UserRoleWhereUniqueInput `json:"connect,omitempty"`
}

type UserRoleCreateInput struct {
	ID         *string        `json:"id,omitempty"`
	Namespace  *RoleNamespace `json:"namespace,omitempty"`
	Permission string         `json:"permission"`
}

type WalletCreateOneInput struct {
	Create  *WalletCreateInput      `json:"create,omitempty"`
	Connect *WalletWhereUniqueInput `json:"connect,omitempty"`
}

type WalletCreateInput struct {
	ID           *string                     `json:"id,omitempty"`
	Balance      *float64                    `json:"balance,omitempty"`
	Transactions *TransactionCreateManyInput `json:"transactions,omitempty"`
}

type TransactionCreateManyInput struct {
	Create  []TransactionCreateInput      `json:"create,omitempty"`
	Connect []TransactionWhereUniqueInput `json:"connect,omitempty"`
}

type UserUpdateInput struct {
	Email         *string                            `json:"email,omitempty"`
	Password      *string                            `json:"password,omitempty"`
	EmailVerified *bool                              `json:"emailVerified,omitempty"`
	Username      *string                            `json:"username,omitempty"`
	Nric          *string                            `json:"nric,omitempty"`
	Profile       *UserProfileUpdateOneRequiredInput `json:"profile,omitempty"`
	Roles         *UserRoleUpdateManyInput           `json:"roles,omitempty"`
	Wallet        *WalletUpdateOneRequiredInput      `json:"wallet,omitempty"`
}

type UserProfileUpdateOneRequiredInput struct {
	Create  *UserProfileCreateInput       `json:"create,omitempty"`
	Update  *UserProfileUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserProfileUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserProfileWhereUniqueInput  `json:"connect,omitempty"`
}

type UserProfileUpdateDataInput struct {
	Address      *string `json:"address,omitempty"`
	Age          *string `json:"age,omitempty"`
	Citizenship  *string `json:"citizenship,omitempty"`
	Country      *string `json:"country,omitempty"`
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	FullName     *string `json:"fullName,omitempty"`
	Occupation   *string `json:"occupation,omitempty"`
	Organisation *string `json:"organisation,omitempty"`
	Phone        *string `json:"phone,omitempty"`
}

type UserProfileUpsertNestedInput struct {
	Update UserProfileUpdateDataInput `json:"update"`
	Create UserProfileCreateInput     `json:"create"`
}

type UserRoleUpdateManyInput struct {
	Create     []UserRoleCreateInput                      `json:"create,omitempty"`
	Update     []UserRoleUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []UserRoleUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []UserRoleWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []UserRoleWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []UserRoleWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []UserRoleWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []UserRoleScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []UserRoleUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type UserRoleUpdateWithWhereUniqueNestedInput struct {
	Where UserRoleWhereUniqueInput `json:"where"`
	Data  UserRoleUpdateDataInput  `json:"data"`
}

type UserRoleUpdateDataInput struct {
	Namespace  *RoleNamespace `json:"namespace,omitempty"`
	Permission *string        `json:"permission,omitempty"`
}

type UserRoleUpsertWithWhereUniqueNestedInput struct {
	Where  UserRoleWhereUniqueInput `json:"where"`
	Update UserRoleUpdateDataInput  `json:"update"`
	Create UserRoleCreateInput      `json:"create"`
}

type UserRoleScalarWhereInput struct {
	ID                      *string                    `json:"id,omitempty"`
	IDNot                   *string                    `json:"id_not,omitempty"`
	IDIn                    []string                   `json:"id_in,omitempty"`
	IDNotIn                 []string                   `json:"id_not_in,omitempty"`
	IDLt                    *string                    `json:"id_lt,omitempty"`
	IDLte                   *string                    `json:"id_lte,omitempty"`
	IDGt                    *string                    `json:"id_gt,omitempty"`
	IDGte                   *string                    `json:"id_gte,omitempty"`
	IDContains              *string                    `json:"id_contains,omitempty"`
	IDNotContains           *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                    `json:"id_not_ends_with,omitempty"`
	Namespace               *RoleNamespace             `json:"namespace,omitempty"`
	NamespaceNot            *RoleNamespace             `json:"namespace_not,omitempty"`
	NamespaceIn             []RoleNamespace            `json:"namespace_in,omitempty"`
	NamespaceNotIn          []RoleNamespace            `json:"namespace_not_in,omitempty"`
	Permission              *string                    `json:"permission,omitempty"`
	PermissionNot           *string                    `json:"permission_not,omitempty"`
	PermissionIn            []string                   `json:"permission_in,omitempty"`
	PermissionNotIn         []string                   `json:"permission_not_in,omitempty"`
	PermissionLt            *string                    `json:"permission_lt,omitempty"`
	PermissionLte           *string                    `json:"permission_lte,omitempty"`
	PermissionGt            *string                    `json:"permission_gt,omitempty"`
	PermissionGte           *string                    `json:"permission_gte,omitempty"`
	PermissionContains      *string                    `json:"permission_contains,omitempty"`
	PermissionNotContains   *string                    `json:"permission_not_contains,omitempty"`
	PermissionStartsWith    *string                    `json:"permission_starts_with,omitempty"`
	PermissionNotStartsWith *string                    `json:"permission_not_starts_with,omitempty"`
	PermissionEndsWith      *string                    `json:"permission_ends_with,omitempty"`
	PermissionNotEndsWith   *string                    `json:"permission_not_ends_with,omitempty"`
	And                     []UserRoleScalarWhereInput `json:"AND,omitempty"`
	Or                      []UserRoleScalarWhereInput `json:"OR,omitempty"`
	Not                     []UserRoleScalarWhereInput `json:"NOT,omitempty"`
}

type UserRoleUpdateManyWithWhereNestedInput struct {
	Where UserRoleScalarWhereInput    `json:"where"`
	Data  UserRoleUpdateManyDataInput `json:"data"`
}

type UserRoleUpdateManyDataInput struct {
	Namespace  *RoleNamespace `json:"namespace,omitempty"`
	Permission *string        `json:"permission,omitempty"`
}

type WalletUpdateOneRequiredInput struct {
	Create  *WalletCreateInput       `json:"create,omitempty"`
	Update  *WalletUpdateDataInput   `json:"update,omitempty"`
	Upsert  *WalletUpsertNestedInput `json:"upsert,omitempty"`
	Connect *WalletWhereUniqueInput  `json:"connect,omitempty"`
}

type WalletUpdateDataInput struct {
	Balance      *float64                    `json:"balance,omitempty"`
	Transactions *TransactionUpdateManyInput `json:"transactions,omitempty"`
}

type TransactionUpdateManyInput struct {
	Create     []TransactionCreateInput                      `json:"create,omitempty"`
	Update     []TransactionUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []TransactionUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []TransactionWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []TransactionWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []TransactionWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []TransactionWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []TransactionScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []TransactionUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type TransactionUpdateWithWhereUniqueNestedInput struct {
	Where TransactionWhereUniqueInput `json:"where"`
	Data  TransactionUpdateDataInput  `json:"data"`
}

type TransactionUpdateDataInput struct {
	Currency *string                  `json:"currency,omitempty"`
	Amount   *float64                 `json:"amount,omitempty"`
	Type     *TransactionType         `json:"type,omitempty"`
	Status   *DepositWithdrawalStatus `json:"status,omitempty"`
}

type TransactionUpsertWithWhereUniqueNestedInput struct {
	Where  TransactionWhereUniqueInput `json:"where"`
	Update TransactionUpdateDataInput  `json:"update"`
	Create TransactionCreateInput      `json:"create"`
}

type TransactionScalarWhereInput struct {
	ID                    *string                       `json:"id,omitempty"`
	IDNot                 *string                       `json:"id_not,omitempty"`
	IDIn                  []string                      `json:"id_in,omitempty"`
	IDNotIn               []string                      `json:"id_not_in,omitempty"`
	IDLt                  *string                       `json:"id_lt,omitempty"`
	IDLte                 *string                       `json:"id_lte,omitempty"`
	IDGt                  *string                       `json:"id_gt,omitempty"`
	IDGte                 *string                       `json:"id_gte,omitempty"`
	IDContains            *string                       `json:"id_contains,omitempty"`
	IDNotContains         *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                       `json:"id_not_ends_with,omitempty"`
	Currency              *string                       `json:"currency,omitempty"`
	CurrencyNot           *string                       `json:"currency_not,omitempty"`
	CurrencyIn            []string                      `json:"currency_in,omitempty"`
	CurrencyNotIn         []string                      `json:"currency_not_in,omitempty"`
	CurrencyLt            *string                       `json:"currency_lt,omitempty"`
	CurrencyLte           *string                       `json:"currency_lte,omitempty"`
	CurrencyGt            *string                       `json:"currency_gt,omitempty"`
	CurrencyGte           *string                       `json:"currency_gte,omitempty"`
	CurrencyContains      *string                       `json:"currency_contains,omitempty"`
	CurrencyNotContains   *string                       `json:"currency_not_contains,omitempty"`
	CurrencyStartsWith    *string                       `json:"currency_starts_with,omitempty"`
	CurrencyNotStartsWith *string                       `json:"currency_not_starts_with,omitempty"`
	CurrencyEndsWith      *string                       `json:"currency_ends_with,omitempty"`
	CurrencyNotEndsWith   *string                       `json:"currency_not_ends_with,omitempty"`
	Amount                *float64                      `json:"amount,omitempty"`
	AmountNot             *float64                      `json:"amount_not,omitempty"`
	AmountIn              []float64                     `json:"amount_in,omitempty"`
	AmountNotIn           []float64                     `json:"amount_not_in,omitempty"`
	AmountLt              *float64                      `json:"amount_lt,omitempty"`
	AmountLte             *float64                      `json:"amount_lte,omitempty"`
	AmountGt              *float64                      `json:"amount_gt,omitempty"`
	AmountGte             *float64                      `json:"amount_gte,omitempty"`
	Type                  *TransactionType              `json:"type,omitempty"`
	TypeNot               *TransactionType              `json:"type_not,omitempty"`
	TypeIn                []TransactionType             `json:"type_in,omitempty"`
	TypeNotIn             []TransactionType             `json:"type_not_in,omitempty"`
	Status                *DepositWithdrawalStatus      `json:"status,omitempty"`
	StatusNot             *DepositWithdrawalStatus      `json:"status_not,omitempty"`
	StatusIn              []DepositWithdrawalStatus     `json:"status_in,omitempty"`
	StatusNotIn           []DepositWithdrawalStatus     `json:"status_not_in,omitempty"`
	CreatedAt             *string                       `json:"createdAt,omitempty"`
	CreatedAtNot          *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                       `json:"updatedAt_gte,omitempty"`
	And                   []TransactionScalarWhereInput `json:"AND,omitempty"`
	Or                    []TransactionScalarWhereInput `json:"OR,omitempty"`
	Not                   []TransactionScalarWhereInput `json:"NOT,omitempty"`
}

type TransactionUpdateManyWithWhereNestedInput struct {
	Where TransactionScalarWhereInput    `json:"where"`
	Data  TransactionUpdateManyDataInput `json:"data"`
}

type TransactionUpdateManyDataInput struct {
	Currency *string                  `json:"currency,omitempty"`
	Amount   *float64                 `json:"amount,omitempty"`
	Type     *TransactionType         `json:"type,omitempty"`
	Status   *DepositWithdrawalStatus `json:"status,omitempty"`
}

type WalletUpsertNestedInput struct {
	Update WalletUpdateDataInput `json:"update"`
	Create WalletCreateInput     `json:"create"`
}

type UserUpdateManyMutationInput struct {
	Email         *string `json:"email,omitempty"`
	Password      *string `json:"password,omitempty"`
	EmailVerified *bool   `json:"emailVerified,omitempty"`
	Username      *string `json:"username,omitempty"`
	Nric          *string `json:"nric,omitempty"`
}

type UserProfileUpdateInput struct {
	Address      *string `json:"address,omitempty"`
	Age          *string `json:"age,omitempty"`
	Citizenship  *string `json:"citizenship,omitempty"`
	Country      *string `json:"country,omitempty"`
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	FullName     *string `json:"fullName,omitempty"`
	Occupation   *string `json:"occupation,omitempty"`
	Organisation *string `json:"organisation,omitempty"`
	Phone        *string `json:"phone,omitempty"`
}

type UserProfileUpdateManyMutationInput struct {
	Address      *string `json:"address,omitempty"`
	Age          *string `json:"age,omitempty"`
	Citizenship  *string `json:"citizenship,omitempty"`
	Country      *string `json:"country,omitempty"`
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	FullName     *string `json:"fullName,omitempty"`
	Occupation   *string `json:"occupation,omitempty"`
	Organisation *string `json:"organisation,omitempty"`
	Phone        *string `json:"phone,omitempty"`
}

type UserRoleUpdateInput struct {
	Namespace  *RoleNamespace `json:"namespace,omitempty"`
	Permission *string        `json:"permission,omitempty"`
}

type UserRoleUpdateManyMutationInput struct {
	Namespace  *RoleNamespace `json:"namespace,omitempty"`
	Permission *string        `json:"permission,omitempty"`
}

type WalletUpdateInput struct {
	Balance      *float64                    `json:"balance,omitempty"`
	Transactions *TransactionUpdateManyInput `json:"transactions,omitempty"`
}

type WalletUpdateManyMutationInput struct {
	Balance *float64 `json:"balance,omitempty"`
}

type CompanyAccountSubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *CompanyAccountWhereInput              `json:"node,omitempty"`
	And                        []CompanyAccountSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CompanyAccountSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CompanyAccountSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FileSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *FileWhereInput              `json:"node,omitempty"`
	And                        []FileSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FileSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FileSubscriptionWhereInput `json:"NOT,omitempty"`
}

type OrderSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *OrderWhereInput              `json:"node,omitempty"`
	And                        []OrderSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OrderSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OrderSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TransactionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *TransactionWhereInput              `json:"node,omitempty"`
	And                        []TransactionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TransactionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TransactionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserProfileSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserProfileWhereInput              `json:"node,omitempty"`
	And                        []UserProfileSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserProfileSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserProfileSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserRoleSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserRoleWhereInput              `json:"node,omitempty"`
	And                        []UserRoleSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserRoleSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserRoleSubscriptionWhereInput `json:"NOT,omitempty"`
}

type WalletSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *WalletWhereInput              `json:"node,omitempty"`
	And                        []WalletSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []WalletSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []WalletSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CompanyAccountExec struct {
	exec *prisma.Exec
}

type OrdersParamsExec struct {
	Where   *OrderWhereInput
	OrderBy *OrderOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CompanyAccountExec) Orders(params *OrdersParamsExec) *OrderExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OrderWhereInput", "OrderOrderByInput", "Order"},
		"orders",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExecArray{ret}
}

func (instance CompanyAccountExec) Exec(ctx context.Context) (*CompanyAccount, error) {
	var v CompanyAccount
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyAccountExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyAccountExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyAccountExecArray) Exec(ctx context.Context) ([]CompanyAccount, error) {
	var v []CompanyAccount
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyAccount struct {
	ID        string  `json:"id"`
	Market    *string `json:"market,omitempty"`
	Balance   float64 `json:"balance"`
	CreatedAt *string `json:"createdAt,omitempty"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

type OrderExec struct {
	exec *prisma.Exec
}

func (instance OrderExec) Exec(ctx context.Context) (*Order, error) {
	var v Order
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderExecArray struct {
	exec *prisma.Exec
}

func (instance OrderExecArray) Exec(ctx context.Context) ([]Order, error) {
	var v []Order
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Order struct {
	ID        string      `json:"id"`
	Type      string      `json:"type"`
	Price     float64     `json:"price"`
	ExitPrice *float64    `json:"exitPrice,omitempty"`
	Amount    float64     `json:"amount"`
	Symbol    string      `json:"symbol"`
	Status    OrderStatus `json:"status"`
	Timeframe string      `json:"timeframe"`
	Market    string      `json:"market"`
	Strategy  string      `json:"strategy"`
	CreatedAt *string     `json:"createdAt,omitempty"`
	UpdatedAt *string     `json:"updatedAt,omitempty"`
}

type CompanyAccountConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CompanyAccountConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CompanyAccountConnectionExec) Edges() *CompanyAccountEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CompanyAccountWhereInput", "CompanyAccountOrderByInput", "CompanyAccountEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "CompanyAccount"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CompanyAccountEdgeExecArray{nodes}
}

func (instance *CompanyAccountConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCompanyAccount"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CompanyAccountConnectionExec) Exec(ctx context.Context) (*CompanyAccountConnection, error) {
	var v CompanyAccountConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyAccountConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyAccountConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyAccountConnectionExecArray) Exec(ctx context.Context) ([]CompanyAccountConnection, error) {
	var v []CompanyAccountConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyAccountConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []CompanyAccountEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type CompanyAccountEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CompanyAccountEdgeExec) Node() *CompanyAccountExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyAccount"},
		"node",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExec{ret}
}

func (instance CompanyAccountEdgeExec) Exec(ctx context.Context) (*CompanyAccountEdge, error) {
	var v CompanyAccountEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyAccountEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyAccountEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyAccountEdgeExecArray) Exec(ctx context.Context) ([]CompanyAccountEdge, error) {
	var v []CompanyAccountEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyAccountEdge struct {
	Node   CompanyAccount `json:"node"`
	Cursor string         `json:"cursor"`
}

type FileExec struct {
	exec *prisma.Exec
}

func (instance FileExec) Exec(ctx context.Context) (*File, error) {
	var v File
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileExecArray struct {
	exec *prisma.Exec
}

func (instance FileExecArray) Exec(ctx context.Context) ([]File, error) {
	var v []File
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type File struct {
	ID        string                  `json:"id"`
	CreatedAt string                  `json:"createdAt"`
	UpdatedAt string                  `json:"updatedAt"`
	Filename  string                  `json:"filename"`
	Mimetype  string                  `json:"mimetype"`
	Encoding  string                  `json:"encoding"`
	Meta      *map[string]interface{} `json:"meta,omitempty"`
	Url       string                  `json:"url"`
}

type FileConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FileConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FileConnectionExec) Edges() *FileEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FileWhereInput", "FileOrderByInput", "FileEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "File"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &FileEdgeExecArray{nodes}
}

func (instance *FileConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFile"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FileConnectionExec) Exec(ctx context.Context) (*FileConnection, error) {
	var v FileConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FileConnectionExecArray) Exec(ctx context.Context) ([]FileConnection, error) {
	var v []FileConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []FileEdge `json:"edges"`
}

type FileEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FileEdgeExec) Node() *FileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "File"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExec{ret}
}

func (instance FileEdgeExec) Exec(ctx context.Context) (*FileEdge, error) {
	var v FileEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FileEdgeExecArray) Exec(ctx context.Context) ([]FileEdge, error) {
	var v []FileEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileEdge struct {
	Node   File   `json:"node"`
	Cursor string `json:"cursor"`
}

type OrderConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OrderConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OrderConnectionExec) Edges() *OrderEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"OrderWhereInput", "OrderOrderByInput", "OrderEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Order"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &OrderEdgeExecArray{nodes}
}

func (instance *OrderConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOrder"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance OrderConnectionExec) Exec(ctx context.Context) (*OrderConnection, error) {
	var v OrderConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OrderConnectionExecArray) Exec(ctx context.Context) ([]OrderConnection, error) {
	var v []OrderConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrderConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []OrderEdge `json:"edges"`
}

type OrderEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OrderEdgeExec) Node() *OrderExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Order"},
		"node",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExec{ret}
}

func (instance OrderEdgeExec) Exec(ctx context.Context) (*OrderEdge, error) {
	var v OrderEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OrderEdgeExecArray) Exec(ctx context.Context) ([]OrderEdge, error) {
	var v []OrderEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrderEdge struct {
	Node   Order  `json:"node"`
	Cursor string `json:"cursor"`
}

type TransactionExec struct {
	exec *prisma.Exec
}

func (instance TransactionExec) Exec(ctx context.Context) (*Transaction, error) {
	var v Transaction
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TransactionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TransactionExecArray struct {
	exec *prisma.Exec
}

func (instance TransactionExecArray) Exec(ctx context.Context) ([]Transaction, error) {
	var v []Transaction
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Transaction struct {
	ID        string                  `json:"id"`
	Currency  string                  `json:"currency"`
	Amount    float64                 `json:"amount"`
	Type      TransactionType         `json:"type"`
	Status    DepositWithdrawalStatus `json:"status"`
	CreatedAt *string                 `json:"createdAt,omitempty"`
	UpdatedAt *string                 `json:"updatedAt,omitempty"`
}

type TransactionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TransactionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TransactionConnectionExec) Edges() *TransactionEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TransactionWhereInput", "TransactionOrderByInput", "TransactionEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Transaction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &TransactionEdgeExecArray{nodes}
}

func (instance *TransactionConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTransaction"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TransactionConnectionExec) Exec(ctx context.Context) (*TransactionConnection, error) {
	var v TransactionConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TransactionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TransactionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TransactionConnectionExecArray) Exec(ctx context.Context) ([]TransactionConnection, error) {
	var v []TransactionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TransactionConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []TransactionEdge `json:"edges"`
}

type TransactionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TransactionEdgeExec) Node() *TransactionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Transaction"},
		"node",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExec{ret}
}

func (instance TransactionEdgeExec) Exec(ctx context.Context) (*TransactionEdge, error) {
	var v TransactionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TransactionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TransactionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TransactionEdgeExecArray) Exec(ctx context.Context) ([]TransactionEdge, error) {
	var v []TransactionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TransactionEdge struct {
	Node   Transaction `json:"node"`
	Cursor string      `json:"cursor"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance *UserExec) Profile() *UserProfileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserProfile"},
		"profile",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

type RolesParamsExec struct {
	Where   *UserRoleWhereInput
	OrderBy *UserRoleOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Roles(params *RolesParamsExec) *UserRoleExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserRoleWhereInput", "UserRoleOrderByInput", "UserRole"},
		"roles",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExecArray{ret}
}

func (instance *UserExec) Wallet() *WalletExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Wallet"},
		"wallet",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID            string  `json:"id"`
	Email         string  `json:"email"`
	Password      string  `json:"password"`
	EmailVerified *bool   `json:"emailVerified,omitempty"`
	Username      *string `json:"username,omitempty"`
	Nric          *string `json:"nric,omitempty"`
	CreatedAt     *string `json:"createdAt,omitempty"`
	UpdatedAt     *string `json:"updatedAt,omitempty"`
}

type UserProfileExec struct {
	exec *prisma.Exec
}

func (instance UserProfileExec) Exec(ctx context.Context) (*UserProfile, error) {
	var v UserProfile
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserProfileExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserProfileExecArray struct {
	exec *prisma.Exec
}

func (instance UserProfileExecArray) Exec(ctx context.Context) ([]UserProfile, error) {
	var v []UserProfile
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserProfile struct {
	ID           string  `json:"id"`
	Address      *string `json:"address,omitempty"`
	Age          *string `json:"age,omitempty"`
	Citizenship  *string `json:"citizenship,omitempty"`
	Country      *string `json:"country,omitempty"`
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	FullName     *string `json:"fullName,omitempty"`
	Occupation   *string `json:"occupation,omitempty"`
	Organisation *string `json:"organisation,omitempty"`
	Phone        *string `json:"phone,omitempty"`
}

type UserRoleExec struct {
	exec *prisma.Exec
}

func (instance UserRoleExec) Exec(ctx context.Context) (*UserRole, error) {
	var v UserRole
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserRoleExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserRoleExecArray struct {
	exec *prisma.Exec
}

func (instance UserRoleExecArray) Exec(ctx context.Context) ([]UserRole, error) {
	var v []UserRole
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserRole struct {
	ID         string         `json:"id"`
	Namespace  *RoleNamespace `json:"namespace,omitempty"`
	Permission string         `json:"permission"`
}

type WalletExec struct {
	exec *prisma.Exec
}

type TransactionsParamsExec struct {
	Where   *TransactionWhereInput
	OrderBy *TransactionOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *WalletExec) Transactions(params *TransactionsParamsExec) *TransactionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TransactionWhereInput", "TransactionOrderByInput", "Transaction"},
		"transactions",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExecArray{ret}
}

func (instance WalletExec) Exec(ctx context.Context) (*Wallet, error) {
	var v Wallet
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletExecArray struct {
	exec *prisma.Exec
}

func (instance WalletExecArray) Exec(ctx context.Context) ([]Wallet, error) {
	var v []Wallet
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Wallet struct {
	ID        string   `json:"id"`
	Balance   *float64 `json:"balance,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type UserProfileConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserProfileConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserProfileConnectionExec) Edges() *UserProfileEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserProfileWhereInput", "UserProfileOrderByInput", "UserProfileEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "UserProfile"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &UserProfileEdgeExecArray{nodes}
}

func (instance *UserProfileConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUserProfile"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserProfileConnectionExec) Exec(ctx context.Context) (*UserProfileConnection, error) {
	var v UserProfileConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserProfileConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserProfileConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserProfileConnectionExecArray) Exec(ctx context.Context) ([]UserProfileConnection, error) {
	var v []UserProfileConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserProfileConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []UserProfileEdge `json:"edges"`
}

type UserProfileEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserProfileEdgeExec) Node() *UserProfileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserProfile"},
		"node",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

func (instance UserProfileEdgeExec) Exec(ctx context.Context) (*UserProfileEdge, error) {
	var v UserProfileEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserProfileEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserProfileEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserProfileEdgeExecArray) Exec(ctx context.Context) ([]UserProfileEdge, error) {
	var v []UserProfileEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserProfileEdge struct {
	Node   UserProfile `json:"node"`
	Cursor string      `json:"cursor"`
}

type UserRoleConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserRoleConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserRoleConnectionExec) Edges() *UserRoleEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserRoleWhereInput", "UserRoleOrderByInput", "UserRoleEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "UserRole"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &UserRoleEdgeExecArray{nodes}
}

func (instance *UserRoleConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUserRole"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserRoleConnectionExec) Exec(ctx context.Context) (*UserRoleConnection, error) {
	var v UserRoleConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserRoleConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserRoleConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserRoleConnectionExecArray) Exec(ctx context.Context) ([]UserRoleConnection, error) {
	var v []UserRoleConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserRoleConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []UserRoleEdge `json:"edges"`
}

type UserRoleEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserRoleEdgeExec) Node() *UserRoleExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserRole"},
		"node",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExec{ret}
}

func (instance UserRoleEdgeExec) Exec(ctx context.Context) (*UserRoleEdge, error) {
	var v UserRoleEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserRoleEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserRoleEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserRoleEdgeExecArray) Exec(ctx context.Context) ([]UserRoleEdge, error) {
	var v []UserRoleEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserRoleEdge struct {
	Node   UserRole `json:"node"`
	Cursor string   `json:"cursor"`
}

type WalletConnectionExec struct {
	exec *prisma.Exec
}

func (instance *WalletConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *WalletConnectionExec) Edges() *WalletEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "WalletEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Wallet"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &WalletEdgeExecArray{nodes}
}

func (instance *WalletConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateWallet"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance WalletConnectionExec) Exec(ctx context.Context) (*WalletConnection, error) {
	var v WalletConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance WalletConnectionExecArray) Exec(ctx context.Context) ([]WalletConnection, error) {
	var v []WalletConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WalletConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []WalletEdge `json:"edges"`
}

type WalletEdgeExec struct {
	exec *prisma.Exec
}

func (instance *WalletEdgeExec) Node() *WalletExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Wallet"},
		"node",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

func (instance WalletEdgeExec) Exec(ctx context.Context) (*WalletEdge, error) {
	var v WalletEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance WalletEdgeExecArray) Exec(ctx context.Context) ([]WalletEdge, error) {
	var v []WalletEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WalletEdge struct {
	Node   Wallet `json:"node"`
	Cursor string `json:"cursor"`
}

type CompanyAccountSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CompanyAccountSubscriptionPayloadExec) Node() *CompanyAccountExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyAccount"},
		"node",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountExec{ret}
}

func (instance *CompanyAccountSubscriptionPayloadExec) PreviousValues() *CompanyAccountPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyAccountPreviousValues"},
		"previousValues",
		[]string{"id", "market", "balance", "createdAt", "updatedAt"})

	return &CompanyAccountPreviousValuesExec{ret}
}

func (instance CompanyAccountSubscriptionPayloadExec) Exec(ctx context.Context) (*CompanyAccountSubscriptionPayload, error) {
	var v CompanyAccountSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyAccountSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyAccountSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyAccountSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CompanyAccountSubscriptionPayload, error) {
	var v []CompanyAccountSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyAccountSubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *CompanyAccount `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type CompanyAccountPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CompanyAccountPreviousValuesExec) Exec(ctx context.Context) (*CompanyAccountPreviousValues, error) {
	var v CompanyAccountPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyAccountPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyAccountPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyAccountPreviousValuesExecArray) Exec(ctx context.Context) ([]CompanyAccountPreviousValues, error) {
	var v []CompanyAccountPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CompanyAccountPreviousValues struct {
	ID        string  `json:"id"`
	Market    *string `json:"market,omitempty"`
	Balance   float64 `json:"balance"`
	CreatedAt *string `json:"createdAt,omitempty"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

type FileSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FileSubscriptionPayloadExec) Node() *FileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "File"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FileExec{ret}
}

func (instance *FileSubscriptionPayloadExec) PreviousValues() *FilePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FilePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "filename", "mimetype", "encoding", "meta", "url"})

	return &FilePreviousValuesExec{ret}
}

func (instance FileSubscriptionPayloadExec) Exec(ctx context.Context) (*FileSubscriptionPayload, error) {
	var v FileSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FileSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FileSubscriptionPayload, error) {
	var v []FileSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *File        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FilePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FilePreviousValuesExec) Exec(ctx context.Context) (*FilePreviousValues, error) {
	var v FilePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FilePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FilePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FilePreviousValuesExecArray) Exec(ctx context.Context) ([]FilePreviousValues, error) {
	var v []FilePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FilePreviousValues struct {
	ID        string                  `json:"id"`
	CreatedAt string                  `json:"createdAt"`
	UpdatedAt string                  `json:"updatedAt"`
	Filename  string                  `json:"filename"`
	Mimetype  string                  `json:"mimetype"`
	Encoding  string                  `json:"encoding"`
	Meta      *map[string]interface{} `json:"meta,omitempty"`
	Url       string                  `json:"url"`
}

type OrderSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OrderSubscriptionPayloadExec) Node() *OrderExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Order"},
		"node",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderExec{ret}
}

func (instance *OrderSubscriptionPayloadExec) PreviousValues() *OrderPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderPreviousValues"},
		"previousValues",
		[]string{"id", "type", "price", "exitPrice", "amount", "symbol", "status", "timeframe", "market", "strategy", "createdAt", "updatedAt"})

	return &OrderPreviousValuesExec{ret}
}

func (instance OrderSubscriptionPayloadExec) Exec(ctx context.Context) (*OrderSubscriptionPayload, error) {
	var v OrderSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OrderSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OrderSubscriptionPayload, error) {
	var v []OrderSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrderSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Order       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type OrderPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OrderPreviousValuesExec) Exec(ctx context.Context) (*OrderPreviousValues, error) {
	var v OrderPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OrderPreviousValuesExecArray) Exec(ctx context.Context) ([]OrderPreviousValues, error) {
	var v []OrderPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OrderPreviousValues struct {
	ID        string      `json:"id"`
	Type      string      `json:"type"`
	Price     float64     `json:"price"`
	ExitPrice *float64    `json:"exitPrice,omitempty"`
	Amount    float64     `json:"amount"`
	Symbol    string      `json:"symbol"`
	Status    OrderStatus `json:"status"`
	Timeframe string      `json:"timeframe"`
	Market    string      `json:"market"`
	Strategy  string      `json:"strategy"`
	CreatedAt *string     `json:"createdAt,omitempty"`
	UpdatedAt *string     `json:"updatedAt,omitempty"`
}

type TransactionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TransactionSubscriptionPayloadExec) Node() *TransactionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Transaction"},
		"node",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionExec{ret}
}

func (instance *TransactionSubscriptionPayloadExec) PreviousValues() *TransactionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TransactionPreviousValues"},
		"previousValues",
		[]string{"id", "currency", "amount", "type", "status", "createdAt", "updatedAt"})

	return &TransactionPreviousValuesExec{ret}
}

func (instance TransactionSubscriptionPayloadExec) Exec(ctx context.Context) (*TransactionSubscriptionPayload, error) {
	var v TransactionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TransactionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TransactionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TransactionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TransactionSubscriptionPayload, error) {
	var v []TransactionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TransactionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Transaction `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TransactionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TransactionPreviousValuesExec) Exec(ctx context.Context) (*TransactionPreviousValues, error) {
	var v TransactionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TransactionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TransactionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TransactionPreviousValuesExecArray) Exec(ctx context.Context) ([]TransactionPreviousValues, error) {
	var v []TransactionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TransactionPreviousValues struct {
	ID        string                  `json:"id"`
	Currency  string                  `json:"currency"`
	Amount    float64                 `json:"amount"`
	Type      TransactionType         `json:"type"`
	Status    DepositWithdrawalStatus `json:"status"`
	CreatedAt *string                 `json:"createdAt,omitempty"`
	UpdatedAt *string                 `json:"updatedAt,omitempty"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "email", "password", "emailVerified", "username", "nric", "createdAt", "updatedAt"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID            string  `json:"id"`
	Email         string  `json:"email"`
	Password      string  `json:"password"`
	EmailVerified *bool   `json:"emailVerified,omitempty"`
	Username      *string `json:"username,omitempty"`
	Nric          *string `json:"nric,omitempty"`
	CreatedAt     *string `json:"createdAt,omitempty"`
	UpdatedAt     *string `json:"updatedAt,omitempty"`
}

type UserProfileSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserProfileSubscriptionPayloadExec) Node() *UserProfileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserProfile"},
		"node",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfileExec{ret}
}

func (instance *UserProfileSubscriptionPayloadExec) PreviousValues() *UserProfilePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserProfilePreviousValues"},
		"previousValues",
		[]string{"id", "address", "age", "citizenship", "country", "dateOfBirth", "fullName", "occupation", "organisation", "phone"})

	return &UserProfilePreviousValuesExec{ret}
}

func (instance UserProfileSubscriptionPayloadExec) Exec(ctx context.Context) (*UserProfileSubscriptionPayload, error) {
	var v UserProfileSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserProfileSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserProfileSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserProfileSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserProfileSubscriptionPayload, error) {
	var v []UserProfileSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserProfileSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *UserProfile `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserProfilePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserProfilePreviousValuesExec) Exec(ctx context.Context) (*UserProfilePreviousValues, error) {
	var v UserProfilePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserProfilePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserProfilePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserProfilePreviousValuesExecArray) Exec(ctx context.Context) ([]UserProfilePreviousValues, error) {
	var v []UserProfilePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserProfilePreviousValues struct {
	ID           string  `json:"id"`
	Address      *string `json:"address,omitempty"`
	Age          *string `json:"age,omitempty"`
	Citizenship  *string `json:"citizenship,omitempty"`
	Country      *string `json:"country,omitempty"`
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	FullName     *string `json:"fullName,omitempty"`
	Occupation   *string `json:"occupation,omitempty"`
	Organisation *string `json:"organisation,omitempty"`
	Phone        *string `json:"phone,omitempty"`
}

type UserRoleSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserRoleSubscriptionPayloadExec) Node() *UserRoleExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserRole"},
		"node",
		[]string{"id", "namespace", "permission"})

	return &UserRoleExec{ret}
}

func (instance *UserRoleSubscriptionPayloadExec) PreviousValues() *UserRolePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserRolePreviousValues"},
		"previousValues",
		[]string{"id", "namespace", "permission"})

	return &UserRolePreviousValuesExec{ret}
}

func (instance UserRoleSubscriptionPayloadExec) Exec(ctx context.Context) (*UserRoleSubscriptionPayload, error) {
	var v UserRoleSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserRoleSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserRoleSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserRoleSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserRoleSubscriptionPayload, error) {
	var v []UserRoleSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserRoleSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *UserRole    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserRolePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserRolePreviousValuesExec) Exec(ctx context.Context) (*UserRolePreviousValues, error) {
	var v UserRolePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserRolePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserRolePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserRolePreviousValuesExecArray) Exec(ctx context.Context) ([]UserRolePreviousValues, error) {
	var v []UserRolePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserRolePreviousValues struct {
	ID         string         `json:"id"`
	Namespace  *RoleNamespace `json:"namespace,omitempty"`
	Permission string         `json:"permission"`
}

type WalletSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *WalletSubscriptionPayloadExec) Node() *WalletExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Wallet"},
		"node",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletExec{ret}
}

func (instance *WalletSubscriptionPayloadExec) PreviousValues() *WalletPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WalletPreviousValues"},
		"previousValues",
		[]string{"id", "balance", "createdAt", "updatedAt"})

	return &WalletPreviousValuesExec{ret}
}

func (instance WalletSubscriptionPayloadExec) Exec(ctx context.Context) (*WalletSubscriptionPayload, error) {
	var v WalletSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance WalletSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WalletSubscriptionPayload, error) {
	var v []WalletSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WalletSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Wallet      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type WalletPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance WalletPreviousValuesExec) Exec(ctx context.Context) (*WalletPreviousValues, error) {
	var v WalletPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance WalletPreviousValuesExecArray) Exec(ctx context.Context) ([]WalletPreviousValues, error) {
	var v []WalletPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type WalletPreviousValues struct {
	ID        string   `json:"id"`
	Balance   *float64 `json:"balance,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
}
